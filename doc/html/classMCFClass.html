<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>MCFClass Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>MCFClass Class Reference<br/>
<small>
[<a class="el" href="group__MCFCLASS__CLASSES.html">Classes in MCFClass.h</a>]</small>
</h1><!-- doxytag: class="MCFClass" -->
<p><code>#include &lt;<a class="el" href="MCFClass_8h_source.html">MCFClass.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MCFClass:</div>
<div class="dynsection">
 <div class="center">
  <img src="classMCFClass.png" usemap="#MCFClass_map" alt=""/>
  <map id="MCFClass_map" name="MCFClass_map">
<area href="classRelaxIV.html" alt="RelaxIV" shape="rect" coords="0,56,71,80"/>
</map>
 </div>
</div>

<p><a href="classMCFClass-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass_1_1Eps.html">Eps</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass_1_1Inf.html">Inf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass_1_1MCFException.html">MCFException</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass_1_1MCFState.html">MCFState</a></td></tr>
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Public types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb308d5c56e12a298bfc0928089348b59"></a> The <a class="el" href="classMCFClass.html">MCFClass</a> defines four main public types:</p>
<ul>
<li>Index, the type of arc and node indices;</li>
</ul>
<ul>
<li>FNumber, the type of flow variables, arc capacities, and node deficits;</li>
</ul>
<ul>
<li>CNumber, the type of flow costs, node potentials, and arc reduced costs;</li>
</ul>
<ul>
<li>FONumber, the type of objective function value.</li>
</ul>
<p>By re-defining the types in this section, most MCFSolver should be made to work with any reasonable choice of data type (= one that is capable of properly representing the data of the instances to be solved). This may be relevant due to an important property of MCF problems: *if all arc capacities and node deficits are integer, then there exists an integral optimal primal solution*, and *if all arc costs are integer, then there exists an integral optimal dual solution*. Even more importantly, *many solution algorithms will in fact produce an integral primal/dual solution for free*, because *every primal/dual solution they generate during the solution process is naturally integral*. Therefore, one can use integer data types to represent everything connected with flows and/or costs if the corresponding data is integer in all instances one needs to solve. This directly translates in significant memory savings and/or speed improvements.</p>
<p>It is the user's responsibility to ensure that these types are set to reasonable values*. So, the experienced user may want to experiment with setting this data properly if memory footprint and/or speed is a primary concern. Note, however, that *not all solution algorithms will happily accept integer data*; one example are Interior-Point approaches, which require both flow and cost variables to be continuous (float). So, the viability of setting integer data (as well as its impact on performances) is strictly related to the specific kind of algorithm used. Since these types are common to all derived classes, they have to be set taking into account the needs of all the solvers that are going to be used, and adapting to the "worst case"; of course, FNumber == CNumber == double is going to always be an acceptable "worst case" setting. <a class="el" href="classMCFClass.html">MCFClass</a> may in a future be defined as a template class, with these as template parameters, but this is currently deemed overkill and avoided.</p>
<p>Finally, note that the above integrality property only holds for *linear* MCF problems. If any arc has a nonzero quadratic cost coefficient, optimal flows and potentials may be fractional even if all the data of the problem (comprised quadratic cost coefficients) is integer. Hence, for *quadratic* MCF solvers, a setting like FNumber == CNumber == double is actually mandatory*, for any reasonable algorithm will typically misbehave otherwise. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#adf2c5c5a390d00dd528b0110fad79c6d">MCFParam</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classMCFClass.html#adf2c5c5a390d00dd528b0110fad79c6da8de59c87bf488cdccf9d0e4fee238bac">kMaxTime</a> =  0, 
<a class="el" href="classMCFClass.html#adf2c5c5a390d00dd528b0110fad79c6da46659efdecf94db4d07b0fff16329746">kMaxIter</a>, 
<a class="el" href="classMCFClass.html#adf2c5c5a390d00dd528b0110fad79c6da12d6c315745daa0ed35aed3546e24348">kEpsFlw</a>, 
<a class="el" href="classMCFClass.html#adf2c5c5a390d00dd528b0110fad79c6da0b900410411a1051c0d23cf540fa4e83">kEpsDfct</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="classMCFClass.html#adf2c5c5a390d00dd528b0110fad79c6dae1295ef217f61f4abdb62793a5bbbcf9">kEpsCst</a>, 
<a class="el" href="classMCFClass.html#adf2c5c5a390d00dd528b0110fad79c6da2eac59e7476b92ebd7448096015cae18">kReopt</a>, 
<a class="el" href="classMCFClass.html#adf2c5c5a390d00dd528b0110fad79c6dab88240524d35e5a927ca3de86eb50c99">kLastParam</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a4a59d3afae313663201fad75a4250df0">MCFStatus</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classMCFClass.html#a4a59d3afae313663201fad75a4250df0ab6b60424c045ec7ee0dfb580b330a16d">kUnSolved</a> =  -1, 
<a class="el" href="classMCFClass.html#a4a59d3afae313663201fad75a4250df0a8275d03b7bf0b289db718041de6721d1">kOK</a> =  0, 
<a class="el" href="classMCFClass.html#a4a59d3afae313663201fad75a4250df0ab476cb2dce5dffdd0baf9d4abc60f003">kStopped</a>, 
<a class="el" href="classMCFClass.html#a4a59d3afae313663201fad75a4250df0a6b92903490b4791a21aeb559dde25b01">kUnfeasible</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="classMCFClass.html#a4a59d3afae313663201fad75a4250df0a6526c4e6c5003c36e1a240dab0254d3a">kUnbounded</a>, 
<a class="el" href="classMCFClass.html#a4a59d3afae313663201fad75a4250df0a3f111b0e0c92e535872dd49ec2353a1b">kError</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a6efc7f71f3ec3253f4b810cfa70870c5">MCFAnswer</a> { <a class="el" href="classMCFClass.html#a6efc7f71f3ec3253f4b810cfa70870c5a04a17113c84e9cabc1f3428152fc0642">kNo</a> =  0, 
<a class="el" href="classMCFClass.html#a6efc7f71f3ec3253f4b810cfa70870c5afa9edbd37d6a94709e733081bc22bfdf">kYes</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a0e544e499b428342eb6c3f702ed3baad">MCFFlFrmt</a> { <a class="el" href="classMCFClass.html#a0e544e499b428342eb6c3f702ed3baada33339f9221acec5b78d5ac016ff6ad7c">kDimacs</a> =  0, 
<a class="el" href="classMCFClass.html#a0e544e499b428342eb6c3f702ed3baadab6aa05ec5ce3fd5d6674a9b06413f4bb">kQDimacs</a>, 
<a class="el" href="classMCFClass.html#a0e544e499b428342eb6c3f702ed3baadabdf0af68d9f403201bb3ac2bdd56def8">kMPS</a>, 
<a class="el" href="classMCFClass.html#a0e544e499b428342eb6c3f702ed3baada4d626e5ee35d3622bdc72c59b3a3e8d9">kFWMPS</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbd0d14b02241db9744a8bf88764bd74"></a><!-- doxytag: member="MCFClass::Index" ref="adbd0d14b02241db9744a8bf88764bd74" args="" -->
typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">index of a node or arc ( &gt;= 0 ) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56d6dddf3cc15c78297aa31e64c9c0ea"></a><!-- doxytag: member="MCFClass::Index_Set" ref="a56d6dddf3cc15c78297aa31e64c9c0ea" args="" -->
typedef <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a56d6dddf3cc15c78297aa31e64c9c0ea">Index_Set</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set (array) of indices <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6d4c1bae7fba5d6307654284cc81a54"></a><!-- doxytag: member="MCFClass::cIndex" ref="af6d4c1bae7fba5d6307654284cc81a54" args="" -->
typedef const <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a read-only index <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4705ce63897cdc6abff7a76e248ac593"></a><!-- doxytag: member="MCFClass::cIndex_Set" ref="a4705ce63897cdc6abff7a76e248ac593" args="" -->
typedef <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">read-only index array <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae09f197b2d8606f7eef3749e8d0ebda3"></a><!-- doxytag: member="MCFClass::SIndex" ref="ae09f197b2d8606f7eef3749e8d0ebda3" args="" -->
typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ae09f197b2d8606f7eef3749e8d0ebda3">SIndex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">index of a node or arc <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35fb95e5fc46099baa44c4447290aa5e"></a><!-- doxytag: member="MCFClass::SIndex_Set" ref="a35fb95e5fc46099baa44c4447290aa5e" args="" -->
typedef <a class="el" href="classMCFClass.html#ae09f197b2d8606f7eef3749e8d0ebda3">SIndex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a35fb95e5fc46099baa44c4447290aa5e">SIndex_Set</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set (array) of indices <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59a7961cccc4a07434b11a137c668b92"></a><!-- doxytag: member="MCFClass::cSIndex" ref="a59a7961cccc4a07434b11a137c668b92" args="" -->
typedef const <a class="el" href="classMCFClass.html#ae09f197b2d8606f7eef3749e8d0ebda3">SIndex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a59a7961cccc4a07434b11a137c668b92">cSIndex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a read-only index <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b54b327d315730fd08489b8ce0def95"></a><!-- doxytag: member="MCFClass::cSIndex_Set" ref="a4b54b327d315730fd08489b8ce0def95" args="" -->
typedef <a class="el" href="classMCFClass.html#a59a7961cccc4a07434b11a137c668b92">cSIndex</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a4b54b327d315730fd08489b8ce0def95">cSIndex_Set</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">read-only index array <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bfe61b260d4fb77be54dd86054d89da"></a><!-- doxytag: member="MCFClass::FNumber" ref="a7bfe61b260d4fb77be54dd86054d89da" args="" -->
typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a7bfe61b260d4fb77be54dd86054d89da">FNumber</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">type of arc flow <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6725dee11b3aebc67e6cd6521360fda7"></a><!-- doxytag: member="MCFClass::FRow" ref="a6725dee11b3aebc67e6cd6521360fda7" args="" -->
typedef <a class="el" href="classMCFClass.html#a7bfe61b260d4fb77be54dd86054d89da">FNumber</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a6725dee11b3aebc67e6cd6521360fda7">FRow</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">vector of flows <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78f86908c9100728d866e49f59e41258"></a><!-- doxytag: member="MCFClass::cFNumber" ref="a78f86908c9100728d866e49f59e41258" args="" -->
typedef const <a class="el" href="classMCFClass.html#a7bfe61b260d4fb77be54dd86054d89da">FNumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a78f86908c9100728d866e49f59e41258">cFNumber</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a read-only flow <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a190fc66cd3ce3f32a3aa39b8496f1592"></a><!-- doxytag: member="MCFClass::cFRow" ref="a190fc66cd3ce3f32a3aa39b8496f1592" args="" -->
typedef <a class="el" href="classMCFClass.html#a78f86908c9100728d866e49f59e41258">cFNumber</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">read-only flow array <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a342b2cbd6ff98b8dbf403f9be7222aa7"></a><!-- doxytag: member="MCFClass::CNumber" ref="a342b2cbd6ff98b8dbf403f9be7222aa7" args="" -->
typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a342b2cbd6ff98b8dbf403f9be7222aa7">CNumber</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">type of arc flow cost <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c03c7f5158b841da3fbb4030dc9dc4a"></a><!-- doxytag: member="MCFClass::CRow" ref="a9c03c7f5158b841da3fbb4030dc9dc4a" args="" -->
typedef <a class="el" href="classMCFClass.html#a342b2cbd6ff98b8dbf403f9be7222aa7">CNumber</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a9c03c7f5158b841da3fbb4030dc9dc4a">CRow</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">vector of costs <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ebea33b2afb032dc569685c69319f52"></a><!-- doxytag: member="MCFClass::cCNumber" ref="a2ebea33b2afb032dc569685c69319f52" args="" -->
typedef const <a class="el" href="classMCFClass.html#a342b2cbd6ff98b8dbf403f9be7222aa7">CNumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a2ebea33b2afb032dc569685c69319f52">cCNumber</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a read-only cost <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02437698e248cb4178a02922faffab71"></a><!-- doxytag: member="MCFClass::cCRow" ref="a02437698e248cb4178a02922faffab71" args="" -->
typedef <a class="el" href="classMCFClass.html#a2ebea33b2afb032dc569685c69319f52">cCNumber</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">read-only cost array <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a3f138730b182b64700c3a01eb77a5fff">FONumber</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a721c1066315c8d1a51efa536954d4409"></a><!-- doxytag: member="MCFClass::cFONumber" ref="a721c1066315c8d1a51efa536954d4409" args="" -->
typedef const <a class="el" href="classMCFClass.html#a3f138730b182b64700c3a01eb77a5fff">FONumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a721c1066315c8d1a51efa536954d4409">cFONumber</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">a read-only o.f. value <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa69518738bb692f9984ed89f1131805"></a><!-- doxytag: member="MCFClass::MCFStatePtr" ref="afa69518738bb692f9984ed89f1131805" args="" -->
typedef <a class="el" href="classMCFClass_1_1MCFState.html">MCFState</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#afa69518738bb692f9984ed89f1131805">MCFStatePtr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">pointer to a <a class="el" href="classMCFClass_1_1MCFState.html">MCFState</a> <br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp559a25fdb98a7d1fd1c3771ac568d5e9"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ad55b4a73e5c50485e6151d3d9cc47621">MCFClass</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> nmx=0, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> mmx=0)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other initializations</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp129a85c6b3259d649d63c1c4537a0a31"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a40e0ec7c47bee9ca0c6ff99c1bfc3d07">LoadNet</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> nmx=0, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> mmx=0, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> pn=0, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> pm=0, <a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a> pU=NULL, <a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a> pC=NULL, <a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a> pDfct=NULL, <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> pSn=NULL, <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> pEn=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ae75951d94c75e25411ca3cec56f75777">LoadDMX</a> (istream &amp;DMXs, bool IsQuad=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a9da3ac25194aed7d02c153d773fdf44f">PreProcess</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a3b0304010a92bd979f8681826f673c89">SetPar</a> (int par, int val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af37b110165d2812395b623ce35b79b48">SetPar</a> (int par, double val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab44d9627bd40aa3d4128d343c6cde994">GetPar</a> (int par, int &amp;val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a5c6eeef72e86cb52ac208c78c8f32edc">GetPar</a> (int par, double &amp;val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a8e6d5c12b01192b1b39ae30cab391315">SetMCFTime</a> (bool TimeIt=true)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Solving the problem</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp57b976bafe0370b4e5e518a397e07b15"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a5e5f91a6212cf33b6a557a950ebea96f">SolveMCF</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a78b8a444e6030a7e508c17c82a54c4f2">MCFGetStatus</a> (void)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading flow solution</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp7f14a8daf3ee2965455f620f530b7f90"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ae11407e8e1e99cb9a5bb21dfde870b70">MCFGetX</a> (<a class="el" href="classMCFClass.html#a6725dee11b3aebc67e6cd6521360fda7">FRow</a> F, <a class="el" href="classMCFClass.html#a56d6dddf3cc15c78297aa31e64c9c0ea">Index_Set</a> nms=NULL, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> stp=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;())=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a987789dbdaeae2ddbe0f7f7f7addd95a">MCFGetX</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#abaae90e2a57d460a4b77f93156895765">HaveNewX</a> (void)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading potentials</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp5b19a9914df6830335e33b009bbb52dc"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a0ab5d16518590d7e9743de609a832d96">MCFGetPi</a> (<a class="el" href="classMCFClass.html#a9c03c7f5158b841da3fbb4030dc9dc4a">CRow</a> P, <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> nms=NULL, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> stp=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;())=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af2f23cc2cb5ce60347988a84c4f1fbeb">MCFGetPi</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a20d045ecdb9170a8df6fcd818261eeb3">HaveNewPi</a> (void)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading reduced costs</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd8f2ae660c66e546867c6a59e1d86cac"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a429da84797238864e6faa9532a59d315">MCFGetRC</a> (<a class="el" href="classMCFClass.html#a9c03c7f5158b841da3fbb4030dc9dc4a">CRow</a> CR, <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> nms=NULL, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> stp=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;())=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ae9cc33f04fdd1b19ca2dff90dfff47f6">MCFGetRC</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a342b2cbd6ff98b8dbf403f9be7222aa7">CNumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ae8e9671292477bb648ebc6deea539433">MCFGetRC</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> i)=0</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading the objective function value</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp1f77e31c0d35ccf4c67b1c880e377cc2"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a3f138730b182b64700c3a01eb77a5fff">FONumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ade949d9a06877e6b5acbe83ded3b5d31">MCFGetFO</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a3f138730b182b64700c3a01eb77a5fff">FONumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ae89a2040e929f39e6b8d127943cc3d3e">MCFGetDFO</a> (void)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getting unfeasibility certificate</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp19b9a4f1492fd470b671fd7fc8eea1eb"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a7bfe61b260d4fb77be54dd86054d89da">FNumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a08b73fb76d8c853ce0fbb513ef0e7822">MCFGetUnfCut</a> (<a class="el" href="classMCFClass.html#a56d6dddf3cc15c78297aa31e64c9c0ea">Index_Set</a> Cut)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getting unboundedness certificate</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6165fc11c10b7d3773c3c89b44b1cf2f"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a42244afa36ac65bdfbb569c771bddf6e">MCFGetUnbCycl</a> (<a class="el" href="classMCFClass.html#a56d6dddf3cc15c78297aa31e64c9c0ea">Index_Set</a> Pred, <a class="el" href="classMCFClass.html#a56d6dddf3cc15c78297aa31e64c9c0ea">Index_Set</a> ArcPred)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Saving/restoring the state of the solver</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp2b3de14aebb9942dc17012b3d6181afc"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass_1_1MCFState.html">MCFStatePtr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a2b7c1d26502a871e82ff002699231a3e">MCFGetState</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a5839f63a1039584754608bd03f5b8d96">MCFPutState</a> (<a class="el" href="classMCFClass_1_1MCFState.html">MCFStatePtr</a> S)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Time the code</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp2dc2dfb0f283ad2658e7e463023434f7"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a0da0f55010f95b1d9ffbee28375d03bb">TimeMCF</a> (double &amp;t_us, double &amp;t_ss)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a8b35e744a87aa42f4a011c4bba8beb63">TimeMCF</a> (void)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Check the solutions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp6e432284be71f24098d1871b49eb6e7b"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#adbc0254cbe638463c09244a6a5027499">CheckPSol</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a50940e4ca7f0efd000a16ee47bec4043">CheckDSol</a> (void)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading graph size</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb79e86f890cfa02abce3431b9d0e1b33"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac62194dc70c7e583678aae34b78b9a44">MCFnmax</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a6acb36fd3004a04ef966646bd81d5fc0">MCFmmax</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a77d2a1546bcadc9a3194855a10aaf2ab">MCFn</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm</a> (void)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading graph topology</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpcc8e760a3e15e233cf7f924039646c16"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aea7fc8f96a670d45ca811c0b855a8782">MCFArcs</a> (<a class="el" href="classMCFClass.html#a56d6dddf3cc15c78297aa31e64c9c0ea">Index_Set</a> Startv, <a class="el" href="classMCFClass.html#a56d6dddf3cc15c78297aa31e64c9c0ea">Index_Set</a> Endv, <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> nms=NULL, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> stp=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;())=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a0a91501d1d95483aadf2f69d1170b609">MCFSNde</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> i)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a27e92deb4af43ad74a92621ae40a872c">MCFENde</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> i)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af24ab4ee54e3560fc337f1f7c0d634b0">MCFSNdes</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a944710f1241c9805965fa790ffb6b392">MCFENdes</a> (void)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading arc costs</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb344131834f264db16b07030f7ce7c45"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ada66e21ba6c4fd6b2387181150c6f8fe">MCFCosts</a> (<a class="el" href="classMCFClass.html#a9c03c7f5158b841da3fbb4030dc9dc4a">CRow</a> Costv, <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> nms=NULL, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> stp=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;())=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a342b2cbd6ff98b8dbf403f9be7222aa7">CNumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#adf83ce8c133b8a5f9bcb66d88e121ea0">MCFCost</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> i)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ae2c4df55156e950f2f26a594f7a3df23">MCFCosts</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a89e888f2f649f3fd5b7a422156d21921">MCFQCoef</a> (<a class="el" href="classMCFClass.html#a9c03c7f5158b841da3fbb4030dc9dc4a">CRow</a> Qv, <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> nms=NULL, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> stp=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a342b2cbd6ff98b8dbf403f9be7222aa7">CNumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a5c5257657cb1a116109b66614ac2a67f">MCFQCoef</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#afc9b676245f6c19d27c2295eec681666">MCFQCoef</a> (void)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading arc capacities</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa18b1af88207b3ff115da4f9ccb6204c"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a447632ea008b104a70df3f959d405ceb">MCFUCaps</a> (<a class="el" href="classMCFClass.html#a6725dee11b3aebc67e6cd6521360fda7">FRow</a> UCapv, <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> nms=NULL, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> stp=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;())=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a7bfe61b260d4fb77be54dd86054d89da">FNumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a921676d5b14a7acd5570381995444118">MCFUCap</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> i)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a353c57dbf57832d6bccef0298b986d0e">MCFUCaps</a> (void)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Reading node deficits</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp886f2935ef8a9d7919902845b868c129"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a08fa20f9b4087303f0264fbf7d52d17d">MCFDfcts</a> (<a class="el" href="classMCFClass.html#a6725dee11b3aebc67e6cd6521360fda7">FRow</a> Dfctv, <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> nms=NULL, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> stp=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;())=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a7bfe61b260d4fb77be54dd86054d89da">FNumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab015a43ffd74f3c38b0a77637d99469e">MCFDfct</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> i)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac7d7a4fb45ea60b5f9fc3fe04a8d851f">MCFDfcts</a> (void)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Write problem to file</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp240fd1fb7f92490266fff9da74761d2f"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a9694ac30a17e73567ff73f862bc49621">WriteMCF</a> (ostream &amp;oStrm, int frmt=0)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Changing the costs</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp9399634ca673fa34e5703a40267c1c43"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aee9e3ebb15a59e7e17cd374c634a7b02">ChgCosts</a> (<a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a> NCost, <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> nms=NULL, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> stp=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;())=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a6f9af9201e5e688f3a320e60232876b0">ChgCost</a> (<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> arc, <a class="el" href="classMCFClass.html#a2ebea33b2afb032dc569685c69319f52">cCNumber</a> NCost)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac19d7ad327c37f58b08f4857bf595984">ChgQCoef</a> (<a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a> NQCoef=NULL, <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> nms=NULL, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> stp=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a684c7848d2979dadf88516c7f65c8a81">ChgQCoef</a> (<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> arc, <a class="el" href="classMCFClass.html#a2ebea33b2afb032dc569685c69319f52">cCNumber</a> NQCoef)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Changing the capacities</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp99a84ee3e2a99b3e05a90364cb9ed5a6"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ada3ccb30a1bbc67e5437ec57a3d4e563">ChgUCaps</a> (<a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a> NCap, <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> nms=NULL, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> stp=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;())=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a28813ce576f05bf9d99421b0c44ee583">ChgUCap</a> (<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> arc, <a class="el" href="classMCFClass.html#a78f86908c9100728d866e49f59e41258">cFNumber</a> NCap)=0</td></tr>
<tr><td colspan="2"><div class="groupHeader">Changing the deficits</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpadd785aad80431570a57962734f8dde7"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a293ab02699e513f055a5b660f17fcfd8">ChgDfcts</a> (<a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a> NDfct, <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> nms=NULL, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> strt=0, <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> stp=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;())=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a851b623cfcb19a012c7ec4f240f03c1f">ChgDfct</a> (<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> node, <a class="el" href="classMCFClass.html#a78f86908c9100728d866e49f59e41258">cFNumber</a> NDfct)=0</td></tr>
<tr><td colspan="2"><div class="groupHeader">Changing graph topology</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp14691b10531a99210ed135880a41dcdb"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ae0009a274cb83d7889e4995ef3c1e647">CloseArc</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> name)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a0035530eb857b4579c260a096910d6c4">IsClosedArc</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> name)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a8382186e9ce61f81ded82097e78ed5ef">DelNode</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> name)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a6d8110182ee02299e2e907bfe7b649ed">OpenArc</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> name)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aa5f549defbc771971247af336dad2818">AddNode</a> (<a class="el" href="classMCFClass.html#a78f86908c9100728d866e49f59e41258">cFNumber</a> aDfct)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a87eadc6911dc14c89bf1d072efb1cb8a">ChangeArc</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> name, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> nSN=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;(), <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> nEN=<a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt; <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> &gt;())=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab08d817be437c6e35adda85e284630ff">DelArc</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> name)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a86a02d32ef88df5c71300db4a95c51b9">IsDeletedArc</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> name)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a781ae6ff620df3e5900c81b7c0ebbe0a">AddArc</a> (<a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> Start, <a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a> End, <a class="el" href="classMCFClass.html#a78f86908c9100728d866e49f59e41258">cFNumber</a> aU, <a class="el" href="classMCFClass.html#a2ebea33b2afb032dc569685c69319f52">cCNumber</a> aC)=0</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructor</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp22a8ec108d963f279c6a6a95aa960a57"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a96b44ac4f0064b4ae17a7d58b5ef2539">~MCFClass</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Managing comparisons.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp9aa9bd89f944889c8c3183c847b3e49b"></a> The following methods are provided for making it easier to perform comparisons, with and without tolerances. </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a53dda76b86a0e0a23008c41a832eb1a3">ETZ</a> (T x, const T eps)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a94045c0316cf18c311fb7bb6bc303784">GTZ</a> (T x, const T eps)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#acb20292b13aab42c8dad012e553bfea9">GEZ</a> (T x, const T eps)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a4f8ae64269f4063582a077632928f82b">LTZ</a> (T x, const T eps)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a31063f37129acefd6eddabd9c826b462">LEZ</a> (T x, const T eps)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac4a7cce9902fd32c6b8d192b58bb8ce9">GT</a> (T x, T y, const T eps)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ad879cecfe3c042c2c028d204e2f7f3fe">LT</a> (T x, T y, const T eps)</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a08b4f8a8b695b3b7747fcf2ffa083a"></a><!-- doxytag: member="MCFClass::n" ref="a1a08b4f8a8b695b3b7747fcf2ffa083a" args="" -->
<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a1a08b4f8a8b695b3b7747fcf2ffa083a">n</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">total number of nodes <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0a1f26caaec29b070b32d1eea998c4a"></a><!-- doxytag: member="MCFClass::nmax" ref="ab0a1f26caaec29b070b32d1eea998c4a" args="" -->
<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ab0a1f26caaec29b070b32d1eea998c4a">nmax</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum number of nodes <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac822529b383493e0f3398da537b34977"></a><!-- doxytag: member="MCFClass::m" ref="ac822529b383493e0f3398da537b34977" args="" -->
<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ac822529b383493e0f3398da537b34977">m</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">total number of arcs <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb664e21caf9922ec153f492cfed4efd"></a><!-- doxytag: member="MCFClass::mmax" ref="aeb664e21caf9922ec153f492cfed4efd" args="" -->
<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aeb664e21caf9922ec153f492cfed4efd">mmax</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum number of arcs <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a844dc956342baf3117fbe3087033085f">status</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0961532fc665268d2592e6ec0e12a07"></a><!-- doxytag: member="MCFClass::Senstv" ref="af0961532fc665268d2592e6ec0e12a07" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af0961532fc665268d2592e6ec0e12a07">Senstv</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">true &lt;=&gt; the latest optimal solution should be exploited <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53c9782c4bd24395a3f52d7630ca71bf"></a><!-- doxytag: member="MCFClass::MCFt" ref="a53c9782c4bd24395a3f52d7630ca71bf" args="" -->
OPTtimers *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a53c9782c4bd24395a3f52d7630ca71bf">MCFt</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">timer for performances evaluation <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5773f9219697fc2056e666ea0902f34"></a><!-- doxytag: member="MCFClass::EpsFlw" ref="af5773f9219697fc2056e666ea0902f34" args="" -->
<a class="el" href="classMCFClass.html#a7bfe61b260d4fb77be54dd86054d89da">FNumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#af5773f9219697fc2056e666ea0902f34">EpsFlw</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">precision for comparing arc flows / capacities <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3574dcf43f63455832684f030afc5f8"></a><!-- doxytag: member="MCFClass::EpsDfct" ref="aa3574dcf43f63455832684f030afc5f8" args="" -->
<a class="el" href="classMCFClass.html#a7bfe61b260d4fb77be54dd86054d89da">FNumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aa3574dcf43f63455832684f030afc5f8">EpsDfct</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">precision for comparing node deficits <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4da53da3478797db482f23db15e3d353"></a><!-- doxytag: member="MCFClass::EpsCst" ref="a4da53da3478797db482f23db15e3d353" args="" -->
<a class="el" href="classMCFClass.html#a342b2cbd6ff98b8dbf403f9be7222aa7">CNumber</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#a4da53da3478797db482f23db15e3d353">EpsCst</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">precision for comparing arc costs <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#ad9a37f6fc52cacde58c2ef399a6a3fe0">MaxTime</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMCFClass.html#aca1100873955b9ba2f634c80e1551eef">MaxIter</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This abstract base class defines a standard interface for (linear or convex quadartic separable) Min Cost Flow (MCF) problem solvers.</p>
<p>The data of the problem consist of a (directed) graph G = ( N , A ) with n = |N| nodes and m = |A| (directed) arcs. Each node `i' has a deficit b[ i ], i.e., the amount of flow that is produced/consumed by the node: source nodes (which produce flow) have negative deficits and sink nodes (which consume flow) have positive deficits. Each arc `(i, j)' has an upper capacity U[ i , j ], a linear cost coefficient C[ i , j ] and a (non negative) quadratic cost coefficient Q[ i , j ]. Flow variables X[ i , j ] represents the amount of flow to be sent on arc (i, j). Parallel arcs, i.e., multiple copies of the same arc `(i, j)' (with possibily different costs and/or capacities) are in general allowed. The formulation of the problem is therefore: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \min \sum_{ (i, j) \in A } C[ i , j ] X[ i, j ] + Q[ i , j ] X[ i, j ]^2 / 2 \]" src="form_0.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ (1) \sum_{ (j, i) \in A } X[ j , i ] - \sum_{ (i, j) \in A } X[ i , j ] = b[ i ] \hspace{1cm} i \in N \]" src="form_1.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ (2) 0 \leq X[ i , j ] \leq U[ i , j ] \hspace{1cm} (i, j) \in A \]" src="form_2.png"/>
</p>
<p> The n equations (1) are the flow conservation constraints and the 2m inequalities (2) are the flow nonnegativity and capacity constraints. At least one of the flow conservation constraints is redundant, as the demands must be balanced (<img class="formulaInl" alt="$\sum_{ i \in N } b[ i ] = 0$" src="form_3.png"/>); indeed, exactly n - ConnectedComponents( G ) flow conservation constraints are redundant, as demands must be balanced in each connected component of G. Let us denote by QA and LA the disjoint subsets of A containing, respectively, "quadratic" arcs (with Q[ i , j ] &gt; 0) and "linear" arcs (with Q[ i , j ] = 0); the (MCF) problem is linear if QA is empty, and nonlinear (convex quadratic) if QA is nonempty.</p>
<p>The dual of the problem is: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \max \sum_{ i \in N } Pi[ i ] b[ i ] - \sum_{ (i, j) \in A } W[ i , j ] U[ i , j ] - \sum_{ (i, j) \in AQ } V[ i , j ]^2 / ( 2 * Q[ i , j ] ) \]" src="form_4.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ (3.a) C[ i , j ] - Pi[ j ] + Pi[ i ] + W[ i , j ] - Z[ i , j ] = 0 \hspace{1cm} (i, j) \in AL \]" src="form_5.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ (3.b) C[ i , j ] - Pi[ j ] + Pi[ i ] + W[ i , j ] - Z[ i , j ] = V[ i , j ] \hspace{1cm} (i, j) \in AQ \]" src="form_6.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ (4.a) W[ i , j ] \geq 0 \hspace{1cm} (i, j) \in A \]" src="form_7.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ (4.b) Z[ i , j ] \geq 0 \hspace{1cm} (i, j) \in A \]" src="form_8.png"/>
</p>
<p>Pi[] is said the vector of node potentials for the problem, W[] are bound variables and Z[] are slack variables. Given Pi[], the quantities </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ RC[ i , j ] = C[ i , j ] + Q[ i , j ] * X[ i , j ] - Pi[ j ] + Pi[ i ] \]" src="form_9.png"/>
</p>
<p> are said the "reduced costs" of arcs.</p>
<p>A primal and dual feasible solution pair is optimal if and only if the complementary slackness conditions </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ RC[ i , j ] > 0 \Rightarrow X[ i , j ] = 0 \]" src="form_10.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ RC[ i , j ] < 0 \Rightarrow X[ i , j ] = U[ i , j ] \]" src="form_11.png"/>
</p>
<p> are satisfied for all arcs (i, j) of A.</p>
<p>The <a class="el" href="classMCFClass.html">MCFClass</a> class provides an interface with methods for managing and solving problems of this kind. Actually, the class can also be used as an interface for more general NonLinear MCF problems, where the cost function either nonseparable ( C( X ) ) or arc-separable ( <img class="formulaInl" alt="$\sum_{ (i, j) \in A } C_{i,j}( X[ i, j ] )$" src="form_12.png"/> ). However, solvers for NonLinear MCF problems are typically objective-function-specific, and there is no standard way for inputting a nonlinear function different from a separable convex quadratic one, so only the simplest form is dealt with in the interface, leaving more complex NonLinear parts to the interface of derived classes. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a3f138730b182b64700c3a01eb77a5fff"></a><!-- doxytag: member="MCFClass::FONumber" ref="a3f138730b182b64700c3a01eb77a5fff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="classMCFClass.html#a3f138730b182b64700c3a01eb77a5fff">MCFClass::FONumber</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>type of the objective function: has to hold sums of products of FNumber(s) by CNumber(s) </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a6efc7f71f3ec3253f4b810cfa70870c5"></a><!-- doxytag: member="MCFClass::MCFAnswer" ref="a6efc7f71f3ec3253f4b810cfa70870c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMCFClass.html#a6efc7f71f3ec3253f4b810cfa70870c5">MCFClass::MCFAnswer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Public enum describing the possible reoptimization status of the MCF solver. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a6efc7f71f3ec3253f4b810cfa70870c5a04a17113c84e9cabc1f3428152fc0642"></a><!-- doxytag: member="kNo" ref="a6efc7f71f3ec3253f4b810cfa70870c5a04a17113c84e9cabc1f3428152fc0642" args="" -->kNo</em>&nbsp;</td><td>
<p>no </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a6efc7f71f3ec3253f4b810cfa70870c5afa9edbd37d6a94709e733081bc22bfdf"></a><!-- doxytag: member="kYes" ref="a6efc7f71f3ec3253f4b810cfa70870c5afa9edbd37d6a94709e733081bc22bfdf" args="" -->kYes</em>&nbsp;</td><td>
<p>yes </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e544e499b428342eb6c3f702ed3baad"></a><!-- doxytag: member="MCFClass::MCFFlFrmt" ref="a0e544e499b428342eb6c3f702ed3baad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMCFClass.html#a0e544e499b428342eb6c3f702ed3baad">MCFClass::MCFFlFrmt</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Public enum describing the possible file formats in <a class="el" href="classMCFClass.html#a9694ac30a17e73567ff73f862bc49621">WriteMCF()</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a0e544e499b428342eb6c3f702ed3baada33339f9221acec5b78d5ac016ff6ad7c"></a><!-- doxytag: member="kDimacs" ref="a0e544e499b428342eb6c3f702ed3baada33339f9221acec5b78d5ac016ff6ad7c" args="" -->kDimacs</em>&nbsp;</td><td>
<p>DIMACS file format for MCF. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0e544e499b428342eb6c3f702ed3baadab6aa05ec5ce3fd5d6674a9b06413f4bb"></a><!-- doxytag: member="kQDimacs" ref="a0e544e499b428342eb6c3f702ed3baadab6aa05ec5ce3fd5d6674a9b06413f4bb" args="" -->kQDimacs</em>&nbsp;</td><td>
<p>quadratic DIMACS file format for MCF </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0e544e499b428342eb6c3f702ed3baadabdf0af68d9f403201bb3ac2bdd56def8"></a><!-- doxytag: member="kMPS" ref="a0e544e499b428342eb6c3f702ed3baadabdf0af68d9f403201bb3ac2bdd56def8" args="" -->kMPS</em>&nbsp;</td><td>
<p>MPS file format for LP. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a0e544e499b428342eb6c3f702ed3baada4d626e5ee35d3622bdc72c59b3a3e8d9"></a><!-- doxytag: member="kFWMPS" ref="a0e544e499b428342eb6c3f702ed3baada4d626e5ee35d3622bdc72c59b3a3e8d9" args="" -->kFWMPS</em>&nbsp;</td><td>
<p>"Fixed Width" MPS format </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="adf2c5c5a390d00dd528b0110fad79c6d"></a><!-- doxytag: member="MCFClass::MCFParam" ref="adf2c5c5a390d00dd528b0110fad79c6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMCFClass.html#adf2c5c5a390d00dd528b0110fad79c6d">MCFClass::MCFParam</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Public enum describing the possible parameters of the MCF solver, to be used with the methods <a class="el" href="classMCFClass.html#a3b0304010a92bd979f8681826f673c89">SetPar()</a> and <a class="el" href="classMCFClass.html#ab44d9627bd40aa3d4128d343c6cde994">GetPar()</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="adf2c5c5a390d00dd528b0110fad79c6da8de59c87bf488cdccf9d0e4fee238bac"></a><!-- doxytag: member="kMaxTime" ref="adf2c5c5a390d00dd528b0110fad79c6da8de59c87bf488cdccf9d0e4fee238bac" args="" -->kMaxTime</em>&nbsp;</td><td>
<p>max time </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf2c5c5a390d00dd528b0110fad79c6da46659efdecf94db4d07b0fff16329746"></a><!-- doxytag: member="kMaxIter" ref="adf2c5c5a390d00dd528b0110fad79c6da46659efdecf94db4d07b0fff16329746" args="" -->kMaxIter</em>&nbsp;</td><td>
<p>max number of iteration </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf2c5c5a390d00dd528b0110fad79c6da12d6c315745daa0ed35aed3546e24348"></a><!-- doxytag: member="kEpsFlw" ref="adf2c5c5a390d00dd528b0110fad79c6da12d6c315745daa0ed35aed3546e24348" args="" -->kEpsFlw</em>&nbsp;</td><td>
<p>tolerance for flows </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf2c5c5a390d00dd528b0110fad79c6da0b900410411a1051c0d23cf540fa4e83"></a><!-- doxytag: member="kEpsDfct" ref="adf2c5c5a390d00dd528b0110fad79c6da0b900410411a1051c0d23cf540fa4e83" args="" -->kEpsDfct</em>&nbsp;</td><td>
<p>tolerance for deficits </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf2c5c5a390d00dd528b0110fad79c6dae1295ef217f61f4abdb62793a5bbbcf9"></a><!-- doxytag: member="kEpsCst" ref="adf2c5c5a390d00dd528b0110fad79c6dae1295ef217f61f4abdb62793a5bbbcf9" args="" -->kEpsCst</em>&nbsp;</td><td>
<p>tolerance for costs </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf2c5c5a390d00dd528b0110fad79c6da2eac59e7476b92ebd7448096015cae18"></a><!-- doxytag: member="kReopt" ref="adf2c5c5a390d00dd528b0110fad79c6da2eac59e7476b92ebd7448096015cae18" args="" -->kReopt</em>&nbsp;</td><td>
<p>whether or not to reoptimize </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="adf2c5c5a390d00dd528b0110fad79c6dab88240524d35e5a927ca3de86eb50c99"></a><!-- doxytag: member="kLastParam" ref="adf2c5c5a390d00dd528b0110fad79c6dab88240524d35e5a927ca3de86eb50c99" args="" -->kLastParam</em>&nbsp;</td><td>
<p>dummy parameter: this is used to allow derived classes to "extend" the set of parameters. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a59d3afae313663201fad75a4250df0"></a><!-- doxytag: member="MCFClass::MCFStatus" ref="a4a59d3afae313663201fad75a4250df0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classMCFClass.html#a4a59d3afae313663201fad75a4250df0">MCFClass::MCFStatus</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Public enum describing the possible status of the MCF solver. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a4a59d3afae313663201fad75a4250df0ab6b60424c045ec7ee0dfb580b330a16d"></a><!-- doxytag: member="kUnSolved" ref="a4a59d3afae313663201fad75a4250df0ab6b60424c045ec7ee0dfb580b330a16d" args="" -->kUnSolved</em>&nbsp;</td><td>
<p>no solution available </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4a59d3afae313663201fad75a4250df0a8275d03b7bf0b289db718041de6721d1"></a><!-- doxytag: member="kOK" ref="a4a59d3afae313663201fad75a4250df0a8275d03b7bf0b289db718041de6721d1" args="" -->kOK</em>&nbsp;</td><td>
<p>optimal solution found </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4a59d3afae313663201fad75a4250df0ab476cb2dce5dffdd0baf9d4abc60f003"></a><!-- doxytag: member="kStopped" ref="a4a59d3afae313663201fad75a4250df0ab476cb2dce5dffdd0baf9d4abc60f003" args="" -->kStopped</em>&nbsp;</td><td>
<p>optimization stopped </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4a59d3afae313663201fad75a4250df0a6b92903490b4791a21aeb559dde25b01"></a><!-- doxytag: member="kUnfeasible" ref="a4a59d3afae313663201fad75a4250df0a6b92903490b4791a21aeb559dde25b01" args="" -->kUnfeasible</em>&nbsp;</td><td>
<p>problem is unfeasible </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4a59d3afae313663201fad75a4250df0a6526c4e6c5003c36e1a240dab0254d3a"></a><!-- doxytag: member="kUnbounded" ref="a4a59d3afae313663201fad75a4250df0a6526c4e6c5003c36e1a240dab0254d3a" args="" -->kUnbounded</em>&nbsp;</td><td>
<p>problem is unbounded </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4a59d3afae313663201fad75a4250df0a3f111b0e0c92e535872dd49ec2353a1b"></a><!-- doxytag: member="kError" ref="a4a59d3afae313663201fad75a4250df0a3f111b0e0c92e535872dd49ec2353a1b" args="" -->kError</em>&nbsp;</td><td>
<p>error in the solver </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad55b4a73e5c50485e6151d3d9cc47621"></a><!-- doxytag: member="MCFClass::MCFClass" ref="ad55b4a73e5c50485e6151d3d9cc47621" args="(cIndex nmx=0, cIndex mmx=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCFClass::MCFClass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>nmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>mmx</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor of the class.</p>
<p>nmx and mmx, if provided, are taken to be respectively the maximum number of nodes and arcs in the network. If nonzero values are passed, memory allocation can be anticipated in the constructor, which is sometimes desirable. The maximum values are stored in the protected fields nmax and mmax, and can be changed with <a class="el" href="classMCFClass.html#a40e0ec7c47bee9ca0c6ff99c1bfc3d07">LoadNet()</a> [see below]; however, changing them typically requires memory allocation/deallocation, which is sometimes undesirable outside the constructor.</p>
<p>After that an object has been constructed, no problem is loaded; this has to be done with <a class="el" href="classMCFClass.html#a40e0ec7c47bee9ca0c6ff99c1bfc3d07">LoadNet()</a> [see below]. Thus, it is an error to invoke any method which requires the presence of a problem (typicall all except those in the initializations part). The base class provides two protected fields n and m for the current number of nodes and arcs, respectively, that are set to 0 in the constructor precisely to indicate that no instance is currently loaded. </p>

</div>
</div>
<a class="anchor" id="a96b44ac4f0064b4ae17a7d58b5ef2539"></a><!-- doxytag: member="MCFClass::~MCFClass" ref="a96b44ac4f0064b4ae17a7d58b5ef2539" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual MCFClass::~MCFClass </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor of the class. The implementation in the base class only deletes the MCFt field. It is virtual, as it should be. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a781ae6ff620df3e5900c81b7c0ebbe0a"></a><!-- doxytag: member="MCFClass::AddArc" ref="a781ae6ff620df3e5900c81b7c0ebbe0a" args="(cIndex Start, cIndex End, cFNumber aU, cCNumber aC)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> MCFClass::AddArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>Start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a78f86908c9100728d866e49f59e41258">cFNumber</a>&nbsp;</td>
          <td class="paramname"> <em>aU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a2ebea33b2afb032dc569685c69319f52">cCNumber</a>&nbsp;</td>
          <td class="paramname"> <em>aC</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the new arc ( Start , End ) with cost aC and capacity aU, returning its name. Inf&lt;Index&gt;() is returned if there is no room for a new arc. Remember that arc names go from 0 to mmax - 1. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#abbb51504142cf57cc14c85608971cb77">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="aa5f549defbc771971247af336dad2818"></a><!-- doxytag: member="MCFClass::AddNode" ref="aa5f549defbc771971247af336dad2818" args="(cFNumber aDfct)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> MCFClass::AddNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a78f86908c9100728d866e49f59e41258">cFNumber</a>&nbsp;</td>
          <td class="paramname"> <em>aDfct</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a new node with deficit aDfct, returning its name. Inf&lt;Index&gt;() is returned if there is no room for a new node. Remember that the node names are either { 0 .. nmax - 1 } or { 1 .. nmax }, depending on the value of USENAME0. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#a89f3619b5b073956ef6f2b9744df3a59">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a87eadc6911dc14c89bf1d072efb1cb8a"></a><!-- doxytag: member="MCFClass::ChangeArc" ref="a87eadc6911dc14c89bf1d072efb1cb8a" args="(cIndex name, cIndex nSN=Inf&lt; Index &gt;(), cIndex nEN=Inf&lt; Index &gt;())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::ChangeArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>nSN</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;&nbsp;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>nEN</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;&nbsp;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the starting and/or ending node of arc `name' to nSN and nEN. Each parameter being Inf&lt;Index&gt;() means to leave the previous starting or ending node untouched. When this method is called `name' can be either the name of a "normal" arc or that of a "closed" arc [see <a class="el" href="classMCFClass.html#ae0009a274cb83d7889e4995ef3c1e647">CloseArc()</a> above]: in the latter case, at the end of <a class="el" href="classMCFClass.html#a87eadc6911dc14c89bf1d072efb1cb8a">ChangeArc()</a> the arc is *still closed*, and it remains so until OpenArc( name ) [see above] is called. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#a26f0d09a93b9cb0fd6f582037958ed82">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a50940e4ca7f0efd000a16ee47bec4043"></a><!-- doxytag: member="MCFClass::CheckDSol" ref="a50940e4ca7f0efd000a16ee47bec4043" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCFClass::CheckDSol </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check that the dual solution returned by the solver is dual feasible. (to within the tolerances set by SetPar(kEps****) [see above], if any). Also, check that the objective function value is correct.</p>
<p>This method is implemented by the base class, using the above methods for collecting the solutions and the methods of the next section for reading the data of the problem; as such, they will work for any derived class that properly implements all these methods. </p>

</div>
</div>
<a class="anchor" id="adbc0254cbe638463c09244a6a5027499"></a><!-- doxytag: member="MCFClass::CheckPSol" ref="adbc0254cbe638463c09244a6a5027499" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCFClass::CheckPSol </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check that the primal solution returned by the solver is primal feasible. (to within the tolerances set by SetPar(kEps****) [see above], if any). Also, check that the objective function value is correct.</p>
<p>This method is implemented by the base class, using the above methods for collecting the solutions and the methods of the next section for reading the data of the problem; as such, they will work for any derived class that properly implements all these methods. </p>

</div>
</div>
<a class="anchor" id="a6f9af9201e5e688f3a320e60232876b0"></a><!-- doxytag: member="MCFClass::ChgCost" ref="a6f9af9201e5e688f3a320e60232876b0" args="(Index arc, cCNumber NCost)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::ChgCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a2ebea33b2afb032dc569685c69319f52">cCNumber</a>&nbsp;</td>
          <td class="paramname"> <em>NCost</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the cost of the i-th arc.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>changing the costs of arcs that *do not exist* is *not allowed*; only arcs which have not been closed/deleted [see <a class="el" href="classMCFClass.html#ae0009a274cb83d7889e4995ef3c1e647">CloseArc()</a> / <a class="el" href="classMCFClass.html#ab08d817be437c6e35adda85e284630ff">DelArc()</a> below and <a class="el" href="classMCFClass.html#a40e0ec7c47bee9ca0c6ff99c1bfc3d07">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a class="anchor" id="aee9e3ebb15a59e7e17cd374c634a7b02"></a><!-- doxytag: member="MCFClass::ChgCosts" ref="aee9e3ebb15a59e7e17cd374c634a7b02" args="(cCRow NCost, cIndex_Set nms=NULL, cIndex strt=0, Index stp=Inf&lt; Index &gt;())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::ChgCosts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a>&nbsp;</td>
          <td class="paramname"> <em>NCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td>
          <td class="paramname"> <em>nms</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>stp</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;&nbsp;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the arc costs. In particular, change the costs that are:</p>
<ul>
<li>listed in into the vector of indices `nms' (ordered in increasing sense and Inf&lt;Index&gt;()-terminated),</li>
</ul>
<ul>
<li>*and* whose name belongs to the interval [`strt', `stp').</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th cost will be changed to NCost[ i ]. If nms == NULL (as the default), *all* the entries in the given range will be changed; if stp &gt; <a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm()</a>, then the smaller bound is used.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>changing the costs of arcs that *do not exist* is *not allowed*; only arcs which have not been closed/deleted [see <a class="el" href="classMCFClass.html#ae0009a274cb83d7889e4995ef3c1e647">CloseArc()</a> / <a class="el" href="classMCFClass.html#ab08d817be437c6e35adda85e284630ff">DelArc()</a> below and <a class="el" href="classMCFClass.html#a40e0ec7c47bee9ca0c6ff99c1bfc3d07">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a class="anchor" id="a851b623cfcb19a012c7ec4f240f03c1f"></a><!-- doxytag: member="MCFClass::ChgDfct" ref="a851b623cfcb19a012c7ec4f240f03c1f" args="(Index node, cFNumber NDfct)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::ChgDfct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a78f86908c9100728d866e49f59e41258">cFNumber</a>&nbsp;</td>
          <td class="paramname"> <em>NDfct</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the deficit of the i-th node.</p>
<p>Note that, in ChgDfct[s](), node "names" (i, strt/ stp or those contained in nms[]) go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit can be changed e.g. with ChgDfcts( 0 , new_deficit ).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>changing the capacities of nodes that *do not exist* is *not allowed*; only nodes that have not been deleted [see <a class="el" href="classMCFClass.html#a8382186e9ce61f81ded82097e78ed5ef">DelNode()</a> below] can be touched with these methods. </dd></dl>

</div>
</div>
<a class="anchor" id="a293ab02699e513f055a5b660f17fcfd8"></a><!-- doxytag: member="MCFClass::ChgDfcts" ref="a293ab02699e513f055a5b660f17fcfd8" args="(cFRow NDfct, cIndex_Set nms=NULL, cIndex strt=0, Index stp=Inf&lt; Index &gt;())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::ChgDfcts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a>&nbsp;</td>
          <td class="paramname"> <em>NDfct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td>
          <td class="paramname"> <em>nms</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>stp</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;&nbsp;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the node deficits. In particular, change the deficits that are:</p>
<ul>
<li>listed in into the vector of indices `nms' (ordered in increasing sense and Inf&lt;Index&gt;()-terminated),</li>
</ul>
<ul>
<li>*and* whose name belongs to the interval [`strt', `stp').</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th deficit will be changed to NDfct[ i ]. If nms == NULL (as the default), *all* the entries in the given range will be changed; if stp &gt; <a class="el" href="classMCFClass.html#a77d2a1546bcadc9a3194855a10aaf2ab">MCFn()</a>, then the smaller bound is used.</p>
<p>Note that, in <a class="el" href="classMCFClass.html#a293ab02699e513f055a5b660f17fcfd8">ChgDfcts()</a>, node "names" (strt, stp or those contained in nms[]) go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit can be changed e.g. with ChgDfcts( &amp;new_deficit , NULL , 0 , 1 ).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>changing the capacities of nodes that *do not exist* is *not allowed*; only nodes that have not been deleted [see <a class="el" href="classMCFClass.html#a8382186e9ce61f81ded82097e78ed5ef">DelNode()</a> below] can be touched with these methods. </dd></dl>

</div>
</div>
<a class="anchor" id="a684c7848d2979dadf88516c7f65c8a81"></a><!-- doxytag: member="MCFClass::ChgQCoef" ref="a684c7848d2979dadf88516c7f65c8a81" args="(Index arc, cCNumber NQCoef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::ChgQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a2ebea33b2afb032dc569685c69319f52">cCNumber</a>&nbsp;</td>
          <td class="paramname"> <em>NQCoef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NQCoef</em>&nbsp;</td><td>Change the quadratic coefficient of the cost of the i-th arc.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the method is *not* pure virtual: an implementation is provided for "pure linear" MCF solvers that only work with all zero quadratic coefficients.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>changing the costs of arcs that *do not exist* is *not allowed*; only arcs which have not been closed/deleted [see <a class="el" href="classMCFClass.html#ae0009a274cb83d7889e4995ef3c1e647">CloseArc()</a> / <a class="el" href="classMCFClass.html#ab08d817be437c6e35adda85e284630ff">DelArc()</a> below and <a class="el" href="classMCFClass.html#a40e0ec7c47bee9ca0c6ff99c1bfc3d07">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a class="anchor" id="ac19d7ad327c37f58b08f4857bf595984"></a><!-- doxytag: member="MCFClass::ChgQCoef" ref="ac19d7ad327c37f58b08f4857bf595984" args="(cCRow NQCoef=NULL, cIndex_Set nms=NULL, cIndex strt=0, Index stp=Inf&lt; Index &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::ChgQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a>&nbsp;</td>
          <td class="paramname"> <em>NQCoef</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td>
          <td class="paramname"> <em>nms</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>stp</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stp</em>&nbsp;</td><td>Change the quadratic coefficients of the arc costs. In particular, change the coefficients that are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>listed in into the vector of indices `nms' (ordered in increasing sense and Inf&lt;Index&gt;()-terminated),</li>
</ul>
<ul>
<li>*and* whose name belongs to the interval [`strt', `stp').</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th cost will be changed to NCost[ i ]. If nms == NULL (as the default), *all* the entries in the given range will be changed; if stp &gt; <a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm()</a>, then the smaller bound is used. If NQCoef == NULL, all the specified coefficients are set to zero.</p>
<p>Note that the method is *not* pure virtual: an implementation is provided for "pure linear" MCF solvers that only work with all zero quadratic coefficients.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>changing the costs of arcs that *do not exist* is *not allowed*; only arcs which have not been closed/deleted [see <a class="el" href="classMCFClass.html#ae0009a274cb83d7889e4995ef3c1e647">CloseArc()</a> / <a class="el" href="classMCFClass.html#ab08d817be437c6e35adda85e284630ff">DelArc()</a> below and <a class="el" href="classMCFClass.html#a40e0ec7c47bee9ca0c6ff99c1bfc3d07">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a class="anchor" id="a28813ce576f05bf9d99421b0c44ee583"></a><!-- doxytag: member="MCFClass::ChgUCap" ref="a28813ce576f05bf9d99421b0c44ee583" args="(Index arc, cFNumber NCap)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::ChgUCap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>arc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a78f86908c9100728d866e49f59e41258">cFNumber</a>&nbsp;</td>
          <td class="paramname"> <em>NCap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the capacity of the i-th arc.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>changing the capacities of arcs that *do not exist* is *not allowed*; only arcs that have not been closed/deleted [see <a class="el" href="classMCFClass.html#ae0009a274cb83d7889e4995ef3c1e647">CloseArc()</a> / <a class="el" href="classMCFClass.html#ab08d817be437c6e35adda85e284630ff">DelArc()</a> below and <a class="el" href="classMCFClass.html#a40e0ec7c47bee9ca0c6ff99c1bfc3d07">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a class="anchor" id="ada3ccb30a1bbc67e5437ec57a3d4e563"></a><!-- doxytag: member="MCFClass::ChgUCaps" ref="ada3ccb30a1bbc67e5437ec57a3d4e563" args="(cFRow NCap, cIndex_Set nms=NULL, cIndex strt=0, Index stp=Inf&lt; Index &gt;())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::ChgUCaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a>&nbsp;</td>
          <td class="paramname"> <em>NCap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td>
          <td class="paramname"> <em>nms</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>stp</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;&nbsp;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the arc capacities. In particular, change the capacities that are:</p>
<ul>
<li>listed in into the vector of indices `nms' (ordered in increasing sense and Inf&lt;Index&gt;()-terminated),</li>
</ul>
<ul>
<li>*and* whose name belongs to the interval [`strt', `stp').</li>
</ul>
<p>That is, if strt &lt;= nms[ i ] &lt; stp, then the nms[ i ]-th capacity will be changed to NCap[ i ]. If nms == NULL (as the default), *all* the entries in the given range will be changed; if stp &gt; <a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm()</a>, then the smaller bound is used.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>changing the capacities of arcs that *do not exist* is *not allowed*; only arcs that have not been closed/deleted [see <a class="el" href="classMCFClass.html#ae0009a274cb83d7889e4995ef3c1e647">CloseArc()</a> / <a class="el" href="classMCFClass.html#ab08d817be437c6e35adda85e284630ff">DelArc()</a> below and <a class="el" href="classMCFClass.html#a40e0ec7c47bee9ca0c6ff99c1bfc3d07">LoadNet()</a> above about C_INF costs] can be touched with these methods. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0009a274cb83d7889e4995ef3c1e647"></a><!-- doxytag: member="MCFClass::CloseArc" ref="ae0009a274cb83d7889e4995ef3c1e647" args="(cIndex name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::CloseArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>"Close" the arc `name'. Although all the associated information (name, cost, capacity, end and start node) is kept, the arc is removed from the problem until OpenArc( i ) [see below] is called.</p>
<p>"closed" arcs always have 0 flow, but are otherwise counted as any other arc; for instance, <a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm()</a> does *not* decrease as an effect of a call to <a class="el" href="classMCFClass.html#ae0009a274cb83d7889e4995ef3c1e647">CloseArc()</a>. How this closure is implemented is solver-specific. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#a68096d62991a1e2d3a2b3d0dc3a9bcf2">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="ab08d817be437c6e35adda85e284630ff"></a><!-- doxytag: member="MCFClass::DelArc" ref="ab08d817be437c6e35adda85e284630ff" args="(cIndex name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::DelArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete the arc `name'. Unlike "closed" arcs, all the information associated with a deleted arc is lost and `name' is made available as a name for new arcs to be created with <a class="el" href="classMCFClass.html#a781ae6ff620df3e5900c81b7c0ebbe0a">AddArc()</a> [see below].</p>
<p>Il furthermore `name' is the last arc, the number of arcs as reported by <a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm()</a> is reduced by at least one, until the m-th arc is not a deleted one. Otherwise, the flow on the arc is always ensured to be 0. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#a374104f3ad539ca151f3f4865cb61628">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a8382186e9ce61f81ded82097e78ed5ef"></a><!-- doxytag: member="MCFClass::DelNode" ref="a8382186e9ce61f81ded82097e78ed5ef" args="(cIndex name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::DelNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete the node `name'.</p>
<p>For any value of `name', all incident arcs to that node are closed [see <a class="el" href="classMCFClass.html#ae0009a274cb83d7889e4995ef3c1e647">CloseArc()</a> above] (*not* Deleted, see <a class="el" href="classMCFClass.html#ab08d817be437c6e35adda85e284630ff">DelArc()</a> below) and the deficit is set to zero.</p>
<p>Il furthermore `name' is the last node, the number of nodes as reported by <a class="el" href="classMCFClass.html#a77d2a1546bcadc9a3194855a10aaf2ab">MCFn()</a> is reduced by at least one, until the n-th node is not a deleted one. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#a007e6fe453b8a5398a7fbe82b75dd014">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a53dda76b86a0e0a23008c41a832eb1a3"></a><!-- doxytag: member="MCFClass::ETZ" ref="a53dda76b86a0e0a23008c41a832eb1a3" args="(T x, const T eps)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool MCFClass::ETZ </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>eps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>true if flow x is equal to zero (possibly considering tolerances). </p>

</div>
</div>
<a class="anchor" id="a5c6eeef72e86cb52ac208c78c8f32edc"></a><!-- doxytag: member="MCFClass::GetPar" ref="a5c6eeef72e86cb52ac208c78c8f32edc" args="(int par, double &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCFClass::GetPar </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns one of the integer parameter of the algorithm.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>par</em>&nbsp;</td><td>is the parameter to return [see SetPar( double ) for comments];</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>upon return, it will contain the value of the parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>The base class implementation handles the parameters kEpsFlw, kEpsDfct, kEpsCst, and kMaxTime. </p>

</div>
</div>
<a class="anchor" id="ab44d9627bd40aa3d4128d343c6cde994"></a><!-- doxytag: member="MCFClass::GetPar" ref="ab44d9627bd40aa3d4128d343c6cde994" args="(int par, int &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCFClass::GetPar </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method returns one of the integer parameter of the algorithm.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>par</em>&nbsp;</td><td>is the parameter to return [see SetPar( int ) for comments];</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>upon return, it will contain the value of the parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>The base class implementation handles the parameters kMaxIter and kReopt. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a81bb3f2d3e5bdf1ad6a646a87492deb4">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="acb20292b13aab42c8dad012e553bfea9"></a><!-- doxytag: member="MCFClass::GEZ" ref="acb20292b13aab42c8dad012e553bfea9" args="(T x, const T eps)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool MCFClass::GEZ </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>eps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>true if flow x is greater than or equal to zero (possibly considering tolerances). </p>

</div>
</div>
<a class="anchor" id="ac4a7cce9902fd32c6b8d192b58bb8ce9"></a><!-- doxytag: member="MCFClass::GT" ref="ac4a7cce9902fd32c6b8d192b58bb8ce9" args="(T x, T y, const T eps)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool MCFClass::GT </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>eps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>true if flow x is greater than flow y (possibly considering tolerances). </p>

</div>
</div>
<a class="anchor" id="a94045c0316cf18c311fb7bb6bc303784"></a><!-- doxytag: member="MCFClass::GTZ" ref="a94045c0316cf18c311fb7bb6bc303784" args="(T x, const T eps)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool MCFClass::GTZ </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>eps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>true if flow x is greater than zero (possibly considering tolerances). </p>

</div>
</div>
<a class="anchor" id="a20d045ecdb9170a8df6fcd818261eeb3"></a><!-- doxytag: member="MCFClass::HaveNewPi" ref="a20d045ecdb9170a8df6fcd818261eeb3" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MCFClass::HaveNewPi </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if a different (approximately) optimal dual solution is available. If the method returns true, then any subsequent call to (any form of) <a class="el" href="classMCFClass.html#af2f23cc2cb5ce60347988a84c4f1fbeb">MCFGetPi()</a> will return a different dual solution, and <a class="el" href="classMCFClass.html#ae9cc33f04fdd1b19ca2dff90dfff47f6">MCFGetRC()</a> [see below] will return the corresponding reduced costs. The new solution need not be optimal (although, ideally, it has to be "good); this can be checked by comparing its objective function value, that will be returned by a call to <a class="el" href="classMCFClass.html#ae89a2040e929f39e6b8d127943cc3d3e">MCFGetDFO()</a> [see below].</p>
<p>Any subsequent call of <a class="el" href="classMCFClass.html#a20d045ecdb9170a8df6fcd818261eeb3">HaveNewPi()</a> that returns true produces a new solution, until the first that returns false; from then on, no new solutions will be generated until something changes in the problem's data.</p>
<p>Note that a default implementation of <a class="el" href="classMCFClass.html#a20d045ecdb9170a8df6fcd818261eeb3">HaveNewPi()</a> is provided which is good for those solvers that only produce one optimal dual solution. </p>

</div>
</div>
<a class="anchor" id="abaae90e2a57d460a4b77f93156895765"></a><!-- doxytag: member="MCFClass::HaveNewX" ref="abaae90e2a57d460a4b77f93156895765" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MCFClass::HaveNewX </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if a different (approximately) optimal primal solution is available. If the method returns true, then any subsequent call to (any form of) <a class="el" href="classMCFClass.html#a987789dbdaeae2ddbe0f7f7f7addd95a">MCFGetX()</a> will return a different primal solution w.r.t. the one that was being returned *before* the call to <a class="el" href="classMCFClass.html#abaae90e2a57d460a4b77f93156895765">HaveNewX()</a>. This solution need not be optimal (although, ideally, it has to be "good); this can be checked by comparing its objective function value, that will be returned by a call to <a class="el" href="classMCFClass.html#ade949d9a06877e6b5acbe83ded3b5d31">MCFGetFO()</a> [see below].</p>
<p>Any subsequent call of <a class="el" href="classMCFClass.html#abaae90e2a57d460a4b77f93156895765">HaveNewX()</a> that returns true produces a new solution, until the first that returns false; from then on, no new solutions will be generated until something changes in the problem's data.</p>
<p>Note that a default implementation of <a class="el" href="classMCFClass.html#abaae90e2a57d460a4b77f93156895765">HaveNewX()</a> is provided which is good for those solvers that only produce one optimal primal solution. </p>

</div>
</div>
<a class="anchor" id="a0035530eb857b4579c260a096910d6c4"></a><!-- doxytag: member="MCFClass::IsClosedArc" ref="a0035530eb857b4579c260a096910d6c4" args="(cIndex name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MCFClass::IsClosedArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classMCFClass.html#a0035530eb857b4579c260a096910d6c4">IsClosedArc()</a> returns true if and only if the arc `name' is closed. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#afdd24b165aabb8c9350a243531d66c70">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a86a02d32ef88df5c71300db4a95c51b9"></a><!-- doxytag: member="MCFClass::IsDeletedArc" ref="a86a02d32ef88df5c71300db4a95c51b9" args="(cIndex name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool MCFClass::IsDeletedArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if and only if the arc `name' is deleted. It should only be called with name &lt; <a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm()</a>, as every other arc is deleted by definition. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#a48ee07066bb71cc4d0fb178415f96a7d">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a31063f37129acefd6eddabd9c826b462"></a><!-- doxytag: member="MCFClass::LEZ" ref="a31063f37129acefd6eddabd9c826b462" args="(T x, const T eps)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool MCFClass::LEZ </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>eps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>true if flow x is less than or equal to zero (possibly considering tolerances). </p>

</div>
</div>
<a class="anchor" id="ae75951d94c75e25411ca3cec56f75777"></a><!-- doxytag: member="MCFClass::LoadDMX" ref="ae75951d94c75e25411ca3cec56f75777" args="(istream &amp;DMXs, bool IsQuad=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCFClass::LoadDMX </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&nbsp;</td>
          <td class="paramname"> <em>DMXs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>IsQuad</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a MCF instance in DIMACS standard format from the istream. The format is the following. The first line must be</p>
<p>p min &lt;number of="" nodes&gt;=""&gt; &lt;number of="" arcs&gt;=""&gt;</p>
<p>Then the node definition lines must be found, in the form</p>
<p>n &lt;node number&gt;=""&gt; &lt;node supply&gt;=""&gt;</p>
<p>Not all nodes need have a node definition line; these are given zero supply, i.e., they are transhipment nodes (supplies are the inverse of deficits, i.e., a node with positive supply is a source node). Finally, the arc definition lines must be found, in the form</p>
<p>a &lt;start node&gt;=""&gt; &lt;end node&gt;=""&gt; &lt;lower bound&gt;=""&gt; &lt;upper bound&gt;=""&gt; &lt;flow cost&gt;=""&gt;</p>
<p>There must be exactly &lt;number of="" arcs&gt;=""&gt; arc definition lines in the file.</p>
<p>This method is *not* pure virtual because an implementation is provided by the base class, using the <a class="el" href="classMCFClass.html#a40e0ec7c47bee9ca0c6ff99c1bfc3d07">LoadNet()</a> method (which *is* pure virtual). However, the method *is* virtual to allow derived classes to implement more efficient versions, should they have any reason to do so.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Actually, the file format accepted by LoadDMX (at least in the base class implementation) is more general than the DIMACS standard format, in that it is allowed to mix node and arc definitions in any order, while the DIMACS file requires all node information to appear before all arc information.</dd>
<dd>
Other than for the above, this method is assumed to allow for quadratic* Dimacs files, encoding for convex quadratic separable Min Cost Flow instances. This is a simple extension where each arc descriptor has a sixth field, &lt;quadratic cost&gt;=""&gt;. The provided istream is assumed to be quadratic Dimacs file if IsQuad is true, and a regular linear Dimacs file otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a40e0ec7c47bee9ca0c6ff99c1bfc3d07"></a><!-- doxytag: member="MCFClass::LoadNet" ref="a40e0ec7c47bee9ca0c6ff99c1bfc3d07" args="(cIndex nmx=0, cIndex mmx=0, cIndex pn=0, cIndex pm=0, cFRow pU=NULL, cCRow pC=NULL, cFRow pDfct=NULL, cIndex_Set pSn=NULL, cIndex_Set pEn=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::LoadNet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>nmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>mmx</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>pn</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>pm</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a>&nbsp;</td>
          <td class="paramname"> <em>pU</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a>&nbsp;</td>
          <td class="paramname"> <em>pC</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a>&nbsp;</td>
          <td class="paramname"> <em>pDfct</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td>
          <td class="paramname"> <em>pSn</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td>
          <td class="paramname"> <em>pEn</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inputs a new network.</p>
<p>The parameters nmx and mmx are the new max number of nodes and arcs, possibly overriding those set in the constructor [see above], altough at the likely cost of memory allocation and deallocation. Passing nmx == mmx == 0 is intended as a signal to the solver to deallocate everything and wait for new orders; in this case, all the other parameters are ignored.</p>
<p>Otherwise, in principle all the other parameters have to be provided. Actually, some of them may not be needed for special classes of MCF problems (e.g., costs in a MaxFlow problem, or start/end nodes in a problem defined over a graph with fixed topology, such as a complete graph). Also, passing NULL is allowed to set default values.</p>
<p>The meaning of the parameters is the following:</p>
<ul>
<li>pn is the current number of nodes of the network (&lt;= nmax).</li>
<li>pm is the number of arcs of the network (&lt;= mmax).</li>
</ul>
<ul>
<li>pU is the m-vector of the arc upper capacities; capacities must be nonnegative, but can in principle be infinite (== F_INF); passing pU == NULL means that all capacities are infinite;</li>
</ul>
<ul>
<li>pC is the m-vector of the arc costs; costs must be finite (&lt; C_INF); passing pC == NULL means that all costs must be 0.</li>
</ul>
<ul>
<li>pDfct is the n-vector of the node deficits; source nodes have negative deficits and sink nodes have positive deficits; passing pDfct == NULL means that all deficits must be 0 (a circulation problem);</li>
</ul>
<ul>
<li>pSn is the m-vector of the arc starting nodes; pSn == NULL is in principle not allowed, unless the topology of the graph is fixed;</li>
<li>pEn is the m-vector of the arc ending nodes; same comments as for pSn.</li>
</ul>
<p>Note that node "names" in the arrays pSn and pEn must go from 1 to pn if the macro USANAME0 [see above] is set to 0, while they must go from 0 to pn - 1 if USANAME0 is set to 1. In both cases, however, the deficit of the first node is read from the first (0-th) position of pDfct, that is if USANAME0 == 0 then the deficit of the node with name `i' is read from pDfct[ i - 1 ].</p>
<p>The data passed to <a class="el" href="classMCFClass.html#a40e0ec7c47bee9ca0c6ff99c1bfc3d07">LoadNet()</a> can be used to specify that the arc `i' must not "exist" in the problem. This is done by passing pC[ i ] == C_INF; solvers which don't read costs are forced to read them in order to check this, unless they provide alternative solver-specific ways to accomplish the same tasks. These arcs are "closed", as for the effect of <a class="el" href="classMCFClass.html#ae0009a274cb83d7889e4995ef3c1e647">CloseArc()</a> [see below]. "invalid" costs (== C_INF) are set to 0 in order to being subsequently capable of "opening" them back with <a class="el" href="classMCFClass.html#a6d8110182ee02299e2e907bfe7b649ed">OpenArc()</a> [see below]. The way in which these non-existent arcs are phisically dealt with is solver-specific; in some solvers, for instance, this could be obtained by simply putting their capacity to zero. Details about these issues should be found in the interface of derived classes.</p>
<p>Note that the quadratic part of the objective function, if any, is not dealt with in <a class="el" href="classMCFClass.html#a40e0ec7c47bee9ca0c6ff99c1bfc3d07">LoadNet()</a>; it can only be separately provided with <a class="el" href="classMCFClass.html#ac19d7ad327c37f58b08f4857bf595984">ChgQCoef()</a> [see below]. By default, the problem is linear, i.e., all coefficients of the second-order terms in the objective function are assumed to be zero. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#a2c069cb12badc0b9244f64bb0bff1359">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="ad879cecfe3c042c2c028d204e2f7f3fe"></a><!-- doxytag: member="MCFClass::LT" ref="ad879cecfe3c042c2c028d204e2f7f3fe" args="(T x, T y, const T eps)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool MCFClass::LT </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>eps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>true if flow x is less than flow y (possibly considering tolerances). </p>

</div>
</div>
<a class="anchor" id="a4f8ae64269f4063582a077632928f82b"></a><!-- doxytag: member="MCFClass::LTZ" ref="a4f8ae64269f4063582a077632928f82b" args="(T x, const T eps)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool MCFClass::LTZ </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>eps</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>true if flow x is less than zero (possibly considering tolerances). </p>

</div>
</div>
<a class="anchor" id="aea7fc8f96a670d45ca811c0b855a8782"></a><!-- doxytag: member="MCFClass::MCFArcs" ref="aea7fc8f96a670d45ca811c0b855a8782" args="(Index_Set Startv, Index_Set Endv, cIndex_Set nms=NULL, cIndex strt=0, Index stp=Inf&lt; Index &gt;())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::MCFArcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a56d6dddf3cc15c78297aa31e64c9c0ea">Index_Set</a>&nbsp;</td>
          <td class="paramname"> <em>Startv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a56d6dddf3cc15c78297aa31e64c9c0ea">Index_Set</a>&nbsp;</td>
          <td class="paramname"> <em>Endv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td>
          <td class="paramname"> <em>nms</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>stp</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;&nbsp;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the starting (tail) and ending (head) nodes of the arcs in Startv[] and Endv[]. If nms == NULL, then the information relative to all arcs is written into Startv[] and Endv[], otherwise Startv[ i ] and Endv[ i ] contain the information relative to arc nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</p>
<p>The parameters `strt' and `stp' allow to restrict the output of the method to all and only the arcs `i' with strt &lt;= i &lt; min( <a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm()</a> , stp ). `strt' and `stp' work in "&amp;&amp;" with nms; that is, if nms != NULL then only the values corresponding to arcs which are *both* in nms and whose index is in the correct range are returned.</p>
<p>Startv or Endv can be NULL, meaning that only the other information is required.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If USENAME0 == 0 then the returned node names will be in the range 1 .. n, while if USENAME0 == 1 the returned node names will be in the range 0 .. n - 1.</dd>
<dd>
If the graph is "dynamic", be careful to use <a class="el" href="classMCFClass.html#a77d2a1546bcadc9a3194855a10aaf2ab">MCFn()</a> e <a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm()</a> to properly choose the dimension of nodes and arcs arrays. </dd></dl>

</div>
</div>
<a class="anchor" id="adf83ce8c133b8a5f9bcb66d88e121ea0"></a><!-- doxytag: member="MCFClass::MCFCost" ref="adf83ce8c133b8a5f9bcb66d88e121ea0" args="(cIndex i)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a342b2cbd6ff98b8dbf403f9be7222aa7">CNumber</a> MCFClass::MCFCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the cost of the i-th arc. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#af2d1014562b6e9a766968b48a6f0645d">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="ae2c4df55156e950f2f26a594f7a3df23"></a><!-- doxytag: member="MCFClass::MCFCosts" ref="ae2c4df55156e950f2f26a594f7a3df23" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a> MCFClass::MCFCosts </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a read-only pointer to an internal vector containing the arc costs. Since this may *not always be available*, depending on the implementation, this method can (uniformly) return NULL. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#aa2b7a4f95736c97f7b56208dfe58d0cb">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="ada66e21ba6c4fd6b2387181150c6f8fe"></a><!-- doxytag: member="MCFClass::MCFCosts" ref="ada66e21ba6c4fd6b2387181150c6f8fe" args="(CRow Costv, cIndex_Set nms=NULL, cIndex strt=0, Index stp=Inf&lt; Index &gt;())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::MCFCosts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a9c03c7f5158b841da3fbb4030dc9dc4a">CRow</a>&nbsp;</td>
          <td class="paramname"> <em>Costv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td>
          <td class="paramname"> <em>nms</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>stp</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;&nbsp;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the arc costs into Costv[]. If nms == NULL, then all the costs are written, otherwise Costv[ i ] contains the information relative to arc nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</p>
<p>The parameters `strt' and `stp' allow to restrict the output of the method to all and only the arcs `i' with strt &lt;= i &lt; min( <a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm()</a> , stp ). `strt' and `stp' work in "&amp;&amp;" with nms; that is, if nms != NULL then only the values corresponding to arcs which are *both* in nms and whose index is in the correct range are returned. </p>

</div>
</div>
<a class="anchor" id="ab015a43ffd74f3c38b0a77637d99469e"></a><!-- doxytag: member="MCFClass::MCFDfct" ref="ab015a43ffd74f3c38b0a77637d99469e" args="(cIndex i)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a7bfe61b260d4fb77be54dd86054d89da">FNumber</a> MCFClass::MCFDfct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the deficit of the i-th node.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Here node "names" go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit is returned by MCFDfct( 0 ). </dd></dl>

<p>Implemented in <a class="el" href="classRelaxIV.html#a94acb96939fd1749bfd4649f225c94a6">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="ac7d7a4fb45ea60b5f9fc3fe04a8d851f"></a><!-- doxytag: member="MCFClass::MCFDfcts" ref="ac7d7a4fb45ea60b5f9fc3fe04a8d851f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a> MCFClass::MCFDfcts </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a read-only pointer to an internal vector containing the node deficits. Since this may *not always be available*, depending on the implementation, this method can (uniformly) return NULL. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Here node "names" go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit is contained in <a class="el" href="classMCFClass.html#ac7d7a4fb45ea60b5f9fc3fe04a8d851f">MCFDfcts()</a>[ 0 ]. </dd></dl>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#ace6acd18a91db7f6700af780f1dd925a">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a08fa20f9b4087303f0264fbf7d52d17d"></a><!-- doxytag: member="MCFClass::MCFDfcts" ref="a08fa20f9b4087303f0264fbf7d52d17d" args="(FRow Dfctv, cIndex_Set nms=NULL, cIndex strt=0, Index stp=Inf&lt; Index &gt;())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::MCFDfcts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a6725dee11b3aebc67e6cd6521360fda7">FRow</a>&nbsp;</td>
          <td class="paramname"> <em>Dfctv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td>
          <td class="paramname"> <em>nms</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>stp</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;&nbsp;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the node deficits into Dfctv[]. If nms == NULL, then all the defcits are written, otherwise Dfctvv[ i ] contains the information relative to node nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</p>
<p>The parameters `strt' and `stp' allow to restrict the output of the method to all and only the nodes `i' with strt &lt;= i &lt; min( <a class="el" href="classMCFClass.html#a77d2a1546bcadc9a3194855a10aaf2ab">MCFn()</a> , stp ). `strt' and `stp' work in "&amp;&amp;" with nms; that is, if nms != NULL then only the values corresponding to nodes which are *both* in nms and whose index is in the correct range are returned.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Here node "names" (strt and stp, those contained in nms[] or `i' in <a class="el" href="classMCFClass.html#ab015a43ffd74f3c38b0a77637d99469e">MCFDfct()</a>) go from 0 to n - 1, regardless to the value of USENAME0; hence, if USENAME0 == 0 then the first node is "named 1", but its deficit is returned by MCFDfcts( Dfctv , NULL , 0 , 1 ). </dd></dl>

</div>
</div>
<a class="anchor" id="a27e92deb4af43ad74a92621ae40a872c"></a><!-- doxytag: member="MCFClass::MCFENde" ref="a27e92deb4af43ad74a92621ae40a872c" args="(cIndex i)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> MCFClass::MCFENde </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the ending (head) node of the arc `i'.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If USENAME0 == 0 then the returned node names will be in the range 1 .. n, while if USENAME0 == 1 the returned node names will be in the range 0 .. n - 1. </dd></dl>

<p>Implemented in <a class="el" href="classRelaxIV.html#a083cc03103846960661128334f4b3c47">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a944710f1241c9805965fa790ffb6b392"></a><!-- doxytag: member="MCFClass::MCFENdes" ref="a944710f1241c9805965fa790ffb6b392" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> MCFClass::MCFENdes </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a read-only pointer to an internal vector containing the ending (head) nodes for each arc. Since this may *not always be available*, depending on the implementation, this method can (uniformly) return NULL. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#ac3d291d85cec53757cbf12440fce129e">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="ae89a2040e929f39e6b8d127943cc3d3e"></a><!-- doxytag: member="MCFClass::MCFGetDFO" ref="ae89a2040e929f39e6b8d127943cc3d3e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a3f138730b182b64700c3a01eb77a5fff">FONumber</a> MCFClass::MCFGetDFO </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the objective function value of the dual solution currently returned by <a class="el" href="classMCFClass.html#af2f23cc2cb5ce60347988a84c4f1fbeb">MCFGetPi()</a> / <a class="el" href="classMCFClass.html#ae9cc33f04fdd1b19ca2dff90dfff47f6">MCFGetRC()</a>. This value (possibly) changes after any call to <a class="el" href="classMCFClass.html#a20d045ecdb9170a8df6fcd818261eeb3">HaveNewPi()</a> that returns true. The relations between <a class="el" href="classMCFClass.html#a78b8a444e6030a7e508c17c82a54c4f2">MCFGetStatus()</a> and <a class="el" href="classMCFClass.html#ae89a2040e929f39e6b8d127943cc3d3e">MCFGetDFO()</a> are analogous to these of <a class="el" href="classMCFClass.html#ade949d9a06877e6b5acbe83ded3b5d31">MCFGetFO()</a>, except that a finite value corresponding to kStopped must be a lower bound on the optimal objective function value (typically, the objective function value one dual feasible solution).</p>
<p>A default implementation is provided for <a class="el" href="classMCFClass.html#ae89a2040e929f39e6b8d127943cc3d3e">MCFGetDFO()</a>, which is good for MCF solvers where the primal and dual optimal solution values always are identical (except if the problem is unfeasible/unbounded). </p>

</div>
</div>
<a class="anchor" id="ade949d9a06877e6b5acbe83ded3b5d31"></a><!-- doxytag: member="MCFClass::MCFGetFO" ref="ade949d9a06877e6b5acbe83ded3b5d31" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a3f138730b182b64700c3a01eb77a5fff">FONumber</a> MCFClass::MCFGetFO </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the objective function value of the primal solution currently returned by <a class="el" href="classMCFClass.html#a987789dbdaeae2ddbe0f7f7f7addd95a">MCFGetX()</a>.</p>
<p>If <a class="el" href="classMCFClass.html#a78b8a444e6030a7e508c17c82a54c4f2">MCFGetStatus()</a> == kOK, this is guaranteed to be the optimal objective function value of the problem (to within the optimality tolerances), but only prior to any call to <a class="el" href="classMCFClass.html#abaae90e2a57d460a4b77f93156895765">HaveNewX()</a> that returns true. <a class="el" href="classMCFClass.html#ade949d9a06877e6b5acbe83ded3b5d31">MCFGetFO()</a> typically returns Inf&lt;FONumber&gt;() if <a class="el" href="classMCFClass.html#a78b8a444e6030a7e508c17c82a54c4f2">MCFGetStatus()</a> == kUnfeasible and</p>
<ul>
<li>Inf&lt;FONumber&gt;() if <a class="el" href="classMCFClass.html#a78b8a444e6030a7e508c17c82a54c4f2">MCFGetStatus()</a> == kUnbounded. If <a class="el" href="classMCFClass.html#a78b8a444e6030a7e508c17c82a54c4f2">MCFGetStatus()</a> == kStopped and <a class="el" href="classMCFClass.html#ade949d9a06877e6b5acbe83ded3b5d31">MCFGetFO()</a> returns a finite value, it must be an upper bound on the optimal objective function value (typically, the objective function value of one primal feasible solution). </li>
</ul>

<p>Implemented in <a class="el" href="classRelaxIV.html#a7bb688576fe8bd5805375b0d6bce8ce9">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="af2f23cc2cb5ce60347988a84c4f1fbeb"></a><!-- doxytag: member="MCFClass::MCFGetPi" ref="af2f23cc2cb5ce60347988a84c4f1fbeb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a> MCFClass::MCFGetPi </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a read-only pointer to an internal data structure containing the node potentials. Since this may *not always be available*, depending on the implementation, this method can (uniformly) return NULL. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a16df3b978df284e8783585495592222e">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a0ab5d16518590d7e9743de609a832d96"></a><!-- doxytag: member="MCFClass::MCFGetPi" ref="a0ab5d16518590d7e9743de609a832d96" args="(CRow P, cIndex_Set nms=NULL, cIndex strt=0, Index stp=Inf&lt; Index &gt;())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::MCFGetPi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a9c03c7f5158b841da3fbb4030dc9dc4a">CRow</a>&nbsp;</td>
          <td class="paramname"> <em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td>
          <td class="paramname"> <em>nms</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>stp</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;&nbsp;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the optimal node potentials in the vector P[]. If nms == NULL, the node potential of node `i' (i in 0 .. n - 1) is written in P[ i ] (note that here node names always start from zero, regardless to the value of USENAME0). If nms != NULL, it must point to a vector of indices in 0 .. n - 1 (ordered in increasing sense and Inf&lt;Index&gt;()-terminated), and the node potential of nms[ i ] is written in P[ i ]. Note that, unlike <a class="el" href="classMCFClass.html#a987789dbdaeae2ddbe0f7f7f7addd95a">MCFGetX()</a> above, nms is an *input* of the method.</p>
<p>The parameters `strt' and `stp' allow to restrict the output of the method to all and only the nodes `i' with strt &lt;= i &lt; min( <a class="el" href="classMCFClass.html#a77d2a1546bcadc9a3194855a10aaf2ab">MCFn()</a> , stp ). `strt' and `stp' work in "&amp;&amp;" with nms; that is, if nms != NULL then only the values corresponding to nodes which are *both* in nms[] and whose index is in the correct range are returned. </p>

</div>
</div>
<a class="anchor" id="ae8e9671292477bb648ebc6deea539433"></a><!-- doxytag: member="MCFClass::MCFGetRC" ref="ae8e9671292477bb648ebc6deea539433" args="(cIndex i)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a342b2cbd6ff98b8dbf403f9be7222aa7">CNumber</a> MCFClass::MCFGetRC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the reduced cost of the i-th arc. This information should be cheapily available in most implementations.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the output of <a class="el" href="classMCFClass.html#ae9cc33f04fdd1b19ca2dff90dfff47f6">MCFGetRC()</a> will change after any call to <a class="el" href="classMCFClass.html#a20d045ecdb9170a8df6fcd818261eeb3">HaveNewPi()</a> [see above] which returns true. </dd></dl>

<p>Implemented in <a class="el" href="classRelaxIV.html#a1e41eae63bba12c32ac2fd57716ef6ad">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="ae9cc33f04fdd1b19ca2dff90dfff47f6"></a><!-- doxytag: member="MCFClass::MCFGetRC" ref="ae9cc33f04fdd1b19ca2dff90dfff47f6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a> MCFClass::MCFGetRC </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a read-only pointer to an internal data structure containing the reduced costs. Since this may *not always be available*, depending on the implementation, this method can (uniformly) return NULL. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the output of <a class="el" href="classMCFClass.html#ae9cc33f04fdd1b19ca2dff90dfff47f6">MCFGetRC()</a> will change after any call to <a class="el" href="classMCFClass.html#a20d045ecdb9170a8df6fcd818261eeb3">HaveNewPi()</a> [see above] which returns true. </dd></dl>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a42a147fabbbfd360762a6c4d8a791348">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a429da84797238864e6faa9532a59d315"></a><!-- doxytag: member="MCFClass::MCFGetRC" ref="a429da84797238864e6faa9532a59d315" args="(CRow CR, cIndex_Set nms=NULL, cIndex strt=0, Index stp=Inf&lt; Index &gt;())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::MCFGetRC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a9c03c7f5158b841da3fbb4030dc9dc4a">CRow</a>&nbsp;</td>
          <td class="paramname"> <em>CR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td>
          <td class="paramname"> <em>nms</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>stp</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;&nbsp;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the reduced costs corresponding to the current dual solution in RC[]. If nms == NULL, the reduced cost of arc `i' (i in 0 .. m - 1) is written in RC[ i ]; if nms != NULL, it must point to a vector of indices in 0 .. m - 1 (ordered in increasing sense and Inf&lt;Index&gt;()-terminated), and the reduced cost of arc nms[ i ] is written in RC[ i ]. Note that, unlike <a class="el" href="classMCFClass.html#a987789dbdaeae2ddbe0f7f7f7addd95a">MCFGetX()</a> above, nms is an *input* of the method.</p>
<p>The parameters `strt' and `stp' allow to restrict the output of the method to all and only the arcs `i' with strt &lt;= i &lt; min( <a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm()</a> , stp ). `strt' and `stp' work in "&amp;&amp;" with nms; that is, if nms != NULL then only the values corresponding to arcs which are *both* in nms[] and whose index is in the correct range are returned.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>the output of <a class="el" href="classMCFClass.html#ae9cc33f04fdd1b19ca2dff90dfff47f6">MCFGetRC()</a> will change after any call to <a class="el" href="classMCFClass.html#a20d045ecdb9170a8df6fcd818261eeb3">HaveNewPi()</a> [see above] which returns true. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b7c1d26502a871e82ff002699231a3e"></a><!-- doxytag: member="MCFClass::MCFGetState" ref="a2b7c1d26502a871e82ff002699231a3e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass_1_1MCFState.html">MCFStatePtr</a> MCFClass::MCFGetState </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Save the state of the MCF solver. The <a class="el" href="classMCFClass.html">MCFClass</a> interface supports the notion of saving and restoring the state of the MCF solver, such as the current/optimal basis in a simplex solver. The "empty" class <a class="el" href="classMCFClass_1_1MCFState.html">MCFState</a> is defined as a placeholder for state descriptions.</p>
<p><a class="el" href="classMCFClass.html#a2b7c1d26502a871e82ff002699231a3e">MCFGetState()</a> creates and returns a pointer to an object of (a proper derived class of) class <a class="el" href="classMCFClass_1_1MCFState.html">MCFState</a> which describes the current state of the MCF solver. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a3cf09aa06b9251d8bb547ca00cde8a1e">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a78b8a444e6030a7e508c17c82a54c4f2"></a><!-- doxytag: member="MCFClass::MCFGetStatus" ref="a78b8a444e6030a7e508c17c82a54c4f2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MCFClass::MCFGetStatus </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an int describing the current status of the MCF solver. Possible return values are:</p>
<ul>
<li>kUnSolved <a class="el" href="classMCFClass.html#a5e5f91a6212cf33b6a557a950ebea96f">SolveMCF()</a> has not been called yet, or the data of the problem has been changed since the last call;</li>
</ul>
<ul>
<li>kOK optimization has been carried out succesfully;</li>
</ul>
<ul>
<li>kStopped optimization have been stopped before that the stopping conditions of the solver applied, e.g. because of the maximum allowed number of "iterations" [see SetPar( int )] or the maximum allowed time [see SetPar( double )] has been reached; this is not necessarily an error, as it might just be required to re-call <a class="el" href="classMCFClass.html#a5e5f91a6212cf33b6a557a950ebea96f">SolveMCF()</a> giving it more "resources" in order to solve the problem;</li>
</ul>
<ul>
<li>kUnfeasible if the current MCF instance is (primal) unfeasible;</li>
</ul>
<ul>
<li>kUnbounded if the current MCF instance is (primal) unbounded (this can only happen if the solver actually allows F_INF capacities, which is nonstandard in the interface);</li>
</ul>
<ul>
<li>kError if there was an error during the optimization; this typically indicates that computation cannot be resumed, although solver-dependent ways of dealing with solver-dependent errors may exist.</li>
</ul>
<p><a class="el" href="classMCFClass.html">MCFClass</a> has a protected <code>int</code> <code>member</code> <code>status</code> <code>that</code> can be used by derived classes to hold status information and that is returned by the standard implementation of this method. Note that <code>status</code> <code>is</code> an <code>int</code> <code>and</code> not an <code>enum</code> <code></code>, and that an <code>int</code> <code>is</code> returned by this method, in order to allow the derived classes to extend the set of return values if they need to do so. </p>

</div>
</div>
<a class="anchor" id="a42244afa36ac65bdfbb569c771bddf6e"></a><!-- doxytag: member="MCFClass::MCFGetUnbCycl" ref="a42244afa36ac65bdfbb569c771bddf6e" args="(Index_Set Pred, Index_Set ArcPred)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> MCFClass::MCFGetUnbCycl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a56d6dddf3cc15c78297aa31e64c9c0ea">Index_Set</a>&nbsp;</td>
          <td class="paramname"> <em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a56d6dddf3cc15c78297aa31e64c9c0ea">Index_Set</a>&nbsp;</td>
          <td class="paramname"> <em>ArcPred</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an unboundedness certificate. In an unbounded MCF problem, unboundedness can always be reduced to the existence of a directed cycle with negative cost and all arcs having infinite capacity. When detecting unboundedness, MCF solvers are typically capable to provide one such cycle. This information can be useful, and this method is provided for getting it. It can be called only if <a class="el" href="classMCFClass.html#a78b8a444e6030a7e508c17c82a54c4f2">MCFGetStatus()</a> == kUnbounded, and writes in Pred[] and ArcPred[], respectively, the node and arc predecessor function of the cycle. That is, if node `i' belongs to the cycle then `Pred[ i ]' contains the name of the predecessor of `j' of `i' in the cycle (note that node names depend on USENAME0), and `ArcPred[ i ]' contains the index of the arc joining the two (note that in general there may be multiple copies of each arc). Entries of the vectors for nodes not belonging to the cycle are in principle undefined, and the name of one node belonging to the cycle is returned by the method. Note that if there are multiple cycles with negative costs this method will return just one of them (finding the cycle with most negative cost is an NO-hard problem), although solvers should be able to produce cycles with "large negative" cost.</p>
<p>However, not all solvers may be (easily) capable of providing this information; thus, returning Inf&lt;Index&gt;() is allowed, as in the base class implementation, to signify that this information is not available. </p>

</div>
</div>
<a class="anchor" id="a08b73fb76d8c853ce0fbb513ef0e7822"></a><!-- doxytag: member="MCFClass::MCFGetUnfCut" ref="a08b73fb76d8c853ce0fbb513ef0e7822" args="(Index_Set Cut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a7bfe61b260d4fb77be54dd86054d89da">FNumber</a> MCFClass::MCFGetUnfCut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a56d6dddf3cc15c78297aa31e64c9c0ea">Index_Set</a>&nbsp;</td>
          <td class="paramname"> <em>Cut</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an unfeasibility certificate. In an unfeasible MCF problem, unfeasibility can always be reduced to the existence of a cut (subset of nodes of the graph) such as either:</p>
<ul>
<li>the inverse of the deficit of the cut (the sum of all the deficits of the nodes in the cut) is larger than the forward capacity of the cut (sum of the capacities of forward arcs in the cut); that is, the nodes in the cut globally produce more flow than can be routed to sinks outside the cut;</li>
</ul>
<ul>
<li>the deficit of the cut is larger than the backward capacity of the cut (sum of the capacities of backward arcs in the cut); that is, the nodes in the cut globally require more flow than can be routed to them from sources outside the cut.</li>
</ul>
<p>When detecting unfeasibility, MCF solvers are typically capable to provide one such cut. This information can be useful - typically, the only way to make the problem feasible is to increase the capacity of at least one of the forward/backward arcs of the cut -, and this method is provided for getting it. It can be called only if <a class="el" href="classMCFClass.html#a78b8a444e6030a7e508c17c82a54c4f2">MCFGetStatus()</a> == kUnfeasible, and should write in Cut the set of names of nodes in the unfeasible cut (note that node names depend on USENAME0), Inf&lt;Index&gt;()-terminated, returning the deficit of the cut (which allows to distinguish which of the two cases above hold). In general, no special properties can be expected from the returned cut, but solvers should be able to provide e.g. "small" cuts.</p>
<p>However, not all solvers may be (easily) capable of providing this information; thus, returning 0 (no cut) is allowed, as in the base class implementation, to signify that this information is not available. </p>

</div>
</div>
<a class="anchor" id="a987789dbdaeae2ddbe0f7f7f7addd95a"></a><!-- doxytag: member="MCFClass::MCFGetX" ref="a987789dbdaeae2ddbe0f7f7f7addd95a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a> MCFClass::MCFGetX </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a read-only pointer to an internal data structure containing the flow solution in "dense" format. Since this may *not always be available*, depending on the implementation, this method can (uniformly) return NULL. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a43a9512f209020d6cb1d0f3ee6b11fba">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="ae11407e8e1e99cb9a5bb21dfde870b70"></a><!-- doxytag: member="MCFClass::MCFGetX" ref="ae11407e8e1e99cb9a5bb21dfde870b70" args="(FRow F, Index_Set nms=NULL, cIndex strt=0, Index stp=Inf&lt; Index &gt;())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::MCFGetX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a6725dee11b3aebc67e6cd6521360fda7">FRow</a>&nbsp;</td>
          <td class="paramname"> <em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a56d6dddf3cc15c78297aa31e64c9c0ea">Index_Set</a>&nbsp;</td>
          <td class="paramname"> <em>nms</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>stp</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;&nbsp;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the optimal flow solution in the vector F[]. If nms == NULL, F[] will be in "dense" format, i.e., the flow relative to arc `i' (i in 0 .. m - 1) is written in F[ i ]. If nms != NULL, F[] will be in "sparse" format, i.e., the indices of the nonzero elements in the flow solution are written in nms (that is then Inf&lt;Index&gt;()-terminated) and the flow value of arc nms[ i ] is written in F[ i ]. Note that nms is not* guaranteed to be ordered. Also, note that, unlike <a class="el" href="classMCFClass.html#ae9cc33f04fdd1b19ca2dff90dfff47f6">MCFGetRC()</a> and <a class="el" href="classMCFClass.html#af2f23cc2cb5ce60347988a84c4f1fbeb">MCFGetPi()</a> [see below], nms is an *output* of the method.</p>
<p>The parameters `strt' and `stp' allow to restrict the output of the method to all and only the arcs `i' with strt &lt;= i &lt; min( <a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm()</a> , stp ). </p>

</div>
</div>
<a class="anchor" id="aa5b7de4894002ec8e47fb8d133a5d5bc"></a><!-- doxytag: member="MCFClass::MCFm" ref="aa5b7de4894002ec8e47fb8d133a5d5bc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> MCFClass::MCFm </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of arcs in the current graph. The implementation of the method in the base class returns the protected fields <code>m</code>, which is provided for derived classes to hold this information. </p>

</div>
</div>
<a class="anchor" id="a6acb36fd3004a04ef966646bd81d5fc0"></a><!-- doxytag: member="MCFClass::MCFmmax" ref="a6acb36fd3004a04ef966646bd81d5fc0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> MCFClass::MCFmmax </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum number of arcs for this instance of <a class="el" href="classMCFClass.html">MCFClass</a>. The implementation of the method in the base class returns the protected fields <code>mmax</code>, which is provided for derived classes to hold this information. </p>

</div>
</div>
<a class="anchor" id="a77d2a1546bcadc9a3194855a10aaf2ab"></a><!-- doxytag: member="MCFClass::MCFn" ref="a77d2a1546bcadc9a3194855a10aaf2ab" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> MCFClass::MCFn </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of nodes in the current graph. The implementation of the method in the base class returns the protected fields <code>n</code>, which is provided for derived classes to hold this information. </p>

</div>
</div>
<a class="anchor" id="ac62194dc70c7e583678aae34b78b9a44"></a><!-- doxytag: member="MCFClass::MCFnmax" ref="ac62194dc70c7e583678aae34b78b9a44" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> MCFClass::MCFnmax </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum number of nodes for this instance of <a class="el" href="classMCFClass.html">MCFClass</a>. The implementation of the method in the base class returns the protected fields <code>nmax</code>, which is provided for derived classes to hold this information. </p>

</div>
</div>
<a class="anchor" id="a5839f63a1039584754608bd03f5b8d96"></a><!-- doxytag: member="MCFClass::MCFPutState" ref="a5839f63a1039584754608bd03f5b8d96" args="(MCFStatePtr S)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::MCFPutState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass_1_1MCFState.html">MCFStatePtr</a>&nbsp;</td>
          <td class="paramname"> <em>S</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Restore the solver to the state in which it was when the state `S' was created with <a class="el" href="classMCFClass.html#a2b7c1d26502a871e82ff002699231a3e">MCFGetState()</a> [see above].</p>
<p>The typical use of this method is the following: a MCF problem is solved and the "optimal state" is set aside. Then the problem changes and it is re-solved. Then, the problem has to be changed again to a form that is close to the original one but rather different from the second one (think of a long backtracking in a Branch &amp; Bound) to which the current "state" referes. Then, the old optimal state can be expected to provide a better starting point for reoptimization [see ReOptimize() below].</p>
<p>Note, however, that the state is only relative to the optimization process, i.e., this operation is meaningless if the data of the problem has changed in the meantime. So, if a state has to be used for speeding up reoptimization, the following has to be done:</p>
<ul>
<li>first, the data of the solver is brought back to *exactly* the same as it was at the moment where the state `S' was created (prior than this operation a ReOptimize( false ) call is probably advisable);</li>
</ul>
<ul>
<li>then, <a class="el" href="classMCFClass.html#a5839f63a1039584754608bd03f5b8d96">MCFPutState()</a> is called (and ReOptimize( true ) is called);</li>
</ul>
<ul>
<li>only afterwards the data of the problem is changed to the final state and the problem is solved.</li>
</ul>
<p>A "put state" operation does not "deplete" the state, which can therefore be used more than once. Indeed, a state is constructed inside the solver for each call to <a class="el" href="classMCFClass.html#a2b7c1d26502a871e82ff002699231a3e">MCFGetState()</a>, but the solver never deletes statuses; this has to be done on the outside when they are no longer needed (the solver must be "resistent" to deletion of the state at any moment).</p>
<p>Since not all the MCF solvers reoptimize (efficiently enough to make these operations worth), an "empty" implementation that does nothing is provided by the base class. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a3a3a3bdf807fce10051a74696968084a">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="afc9b676245f6c19d27c2295eec681666"></a><!-- doxytag: member="MCFClass::MCFQCoef" ref="afc9b676245f6c19d27c2295eec681666" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a02437698e248cb4178a02922faffab71">cCRow</a> MCFClass::MCFQCoef </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a read-only pointer to an internal vector containing the arc costs. Since this may *not always be available*, depending on the implementation, this method can (uniformly) return NULL. This is done by the base class already, so a derived class that does not have the information ready (such as "pure linear" MCF solvers that only work with all zero quadratic coefficients) does not need to implement the method. </p>

</div>
</div>
<a class="anchor" id="a5c5257657cb1a116109b66614ac2a67f"></a><!-- doxytag: member="MCFClass::MCFQCoef" ref="a5c5257657cb1a116109b66614ac2a67f" args="(cIndex i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a342b2cbd6ff98b8dbf403f9be7222aa7">CNumber</a> MCFClass::MCFQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>Return the quadratic coefficients of the cost of the i-th arc. Note that the method is *not* pure virtual: an implementation is provided for "pure
   linear" MCF solvers that only work with all zero quadratic coefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89e888f2f649f3fd5b7a422156d21921"></a><!-- doxytag: member="MCFClass::MCFQCoef" ref="a89e888f2f649f3fd5b7a422156d21921" args="(CRow Qv, cIndex_Set nms=NULL, cIndex strt=0, Index stp=Inf&lt; Index &gt;())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::MCFQCoef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a9c03c7f5158b841da3fbb4030dc9dc4a">CRow</a>&nbsp;</td>
          <td class="paramname"> <em>Qv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td>
          <td class="paramname"> <em>nms</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>stp</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stp</em>&nbsp;</td><td>Write the quadratic coefficients of the arc costs into Qv[]. If nms == NULL, then all the costs are written, otherwise Costv[ i ] contains the information relative to arc nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</td></tr>
  </table>
  </dd>
</dl>
<p>The parameters `strt' and `stp' allow to restrict the output of the method to all and only the arcs `i' with strt &lt;= i &lt; min( <a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm()</a> , stp ). `strt' and `stp' work in "&amp;&amp;" with nms; that is, if nms != NULL then only the values corresponding to arcs which are *both* in nms and whose index is in the correct range are returned.</p>
<p>Note that the method is *not* pure virtual: an implementation is provided for "pure linear" MCF solvers that only work with all zero quadratic coefficients. </p>

</div>
</div>
<a class="anchor" id="a0a91501d1d95483aadf2f69d1170b609"></a><!-- doxytag: member="MCFClass::MCFSNde" ref="a0a91501d1d95483aadf2f69d1170b609" args="(cIndex i)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a> MCFClass::MCFSNde </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the starting (tail) node of the arc `i'.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If USENAME0 == 0 then the returned node names will be in the range 1 .. n, while if USENAME0 == 1 the returned node names will be in the range 0 .. n - 1. </dd></dl>

<p>Implemented in <a class="el" href="classRelaxIV.html#ad60cbf7764bbf3934f60f7acc5028f38">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="af24ab4ee54e3560fc337f1f7c0d634b0"></a><!-- doxytag: member="MCFClass::MCFSNdes" ref="af24ab4ee54e3560fc337f1f7c0d634b0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a> MCFClass::MCFSNdes </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a read-only pointer to an internal vector containing the starting (tail) nodes for each arc. Since this may *not always be available*, depending on the implementation, this method can (uniformly) return NULL. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#af902ac3a8ca551072ac45e65f3e304a6">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a921676d5b14a7acd5570381995444118"></a><!-- doxytag: member="MCFClass::MCFUCap" ref="a921676d5b14a7acd5570381995444118" args="(cIndex i)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a7bfe61b260d4fb77be54dd86054d89da">FNumber</a> MCFClass::MCFUCap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>i</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the capacity of the i-th arc. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#a335715b7e44a11aa67e3686b2b6889c1">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a353c57dbf57832d6bccef0298b986d0e"></a><!-- doxytag: member="MCFClass::MCFUCaps" ref="a353c57dbf57832d6bccef0298b986d0e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMCFClass.html#a190fc66cd3ce3f32a3aa39b8496f1592">cFRow</a> MCFClass::MCFUCaps </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a read-only pointer to an internal vector containing the arc capacities. Since this may *not always be available*, depending on the implementation, this method can (uniformly) return NULL. This is done by the base class already, so a derived class that does not have the information ready does not need to implement the method. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a8857825c19bc88283066a5efd274fe17">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a447632ea008b104a70df3f959d405ceb"></a><!-- doxytag: member="MCFClass::MCFUCaps" ref="a447632ea008b104a70df3f959d405ceb" args="(FRow UCapv, cIndex_Set nms=NULL, cIndex strt=0, Index stp=Inf&lt; Index &gt;())=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::MCFUCaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a6725dee11b3aebc67e6cd6521360fda7">FRow</a>&nbsp;</td>
          <td class="paramname"> <em>UCapv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#a4705ce63897cdc6abff7a76e248ac593">cIndex_Set</a>&nbsp;</td>
          <td class="paramname"> <em>nms</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>strt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;</td>
          <td class="paramname"> <em>stp</em> = <code><a class="el" href="classMCFClass_1_1Inf.html">Inf</a>&lt;&nbsp;<a class="el" href="classMCFClass.html#adbd0d14b02241db9744a8bf88764bd74">Index</a>&nbsp;&gt;()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the arc capacities into UCapv[]. If nms == NULL, then all the capacities are written, otherwise UCapv[ i ] contains the information relative to arc nms[ i ] (nms[] must be Inf&lt;Index&gt;()-terminated).</p>
<p>The parameters `strt' and `stp' allow to restrict the output of the method to all and only the arcs `i' with strt &lt;= i &lt; min( <a class="el" href="classMCFClass.html#aa5b7de4894002ec8e47fb8d133a5d5bc">MCFm()</a> , stp ). `strt' and `stp' work in "&amp;&amp;" with nms; that is, if nms != NULL then only the values corresponding to arcs which are *both* in nms and whose index is in the correct range are returned. </p>

</div>
</div>
<a class="anchor" id="a6d8110182ee02299e2e907bfe7b649ed"></a><!-- doxytag: member="MCFClass::OpenArc" ref="a6d8110182ee02299e2e907bfe7b649ed" args="(cIndex name)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::OpenArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMCFClass.html#af6d4c1bae7fba5d6307654284cc81a54">cIndex</a>&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Restore the previously closed arc `name'. It is an error to open an arc that has not been previously closed. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#a15300e6bb1de665276daa8ea55b19e8c">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a9da3ac25194aed7d02c153d773fdf44f"></a><!-- doxytag: member="MCFClass::PreProcess" ref="a9da3ac25194aed7d02c153d773fdf44f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::PreProcess </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extract a smaller/easier equivalent MCF problem. The data of the instance is changed and the easier one is solved instead of the original one. In the MCF case, preprocessing may involve reducing bounds, identifying disconnected components of the graph etc. However, proprocessing is solver-specific.</p>
<p>This method can be implemented by derived classes in their solver-specific way. Preprocessing may reveal unboundedness or unfeasibility of the problem; if that happens, <a class="el" href="classMCFClass.html#a9da3ac25194aed7d02c153d773fdf44f">PreProcess()</a> should properly set the `status' field, that can then be read with <a class="el" href="classMCFClass.html#a78b8a444e6030a7e508c17c82a54c4f2">MCFGetStatus()</a> [see below].</p>
<p>Note that preprocessing may destroy all the solution information. Also, it may be allowed to change the data of the problem, such as costs/capacities of the arcs.</p>
<p>A valid preprocessing is doing nothing, and that's what the default implementation of this method (that is *not* pure virtual) does. </p>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#aa0df72b7ac9111278b7716ec38c2e09f">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a8e6d5c12b01192b1b39ae30cab391315"></a><!-- doxytag: member="MCFClass::SetMCFTime" ref="a8e6d5c12b01192b1b39ae30cab391315" args="(bool TimeIt=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::SetMCFTime </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>TimeIt</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate an OPTtimers object [see OPTtypes.h] to be used for timing the methods of the class. The time can be read with <a class="el" href="classMCFClass.html#a8b35e744a87aa42f4a011c4bba8beb63">TimeMCF()</a> [see below]. By default, or if SetMCFTime( false ) is called, no timing is done. Note that, since all the relevant methods ot the class are pure virtual, <a class="el" href="classMCFClass.html">MCFClass</a> can only manage the OPTtimers object, but it is due to derived classes to actually implement the timing.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>time accumulates over the calls: calling <a class="el" href="classMCFClass.html#a8e6d5c12b01192b1b39ae30cab391315">SetMCFTime()</a>, however, resets the counters, allowing to time specific groups of calls.</dd>
<dd>
of course, setting kMaxTime [see <a class="el" href="classMCFClass.html#a3b0304010a92bd979f8681826f673c89">SetPar()</a> above] to any nonzero value has no effect unless SetMCFTime( true ) has been called. </dd></dl>

</div>
</div>
<a class="anchor" id="af37b110165d2812395b623ce35b79b48"></a><!-- doxytag: member="MCFClass::SetPar" ref="af37b110165d2812395b623ce35b79b48" args="(int par, double val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCFClass::SetPar </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set float parameters of the algorithm.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>par</em>&nbsp;</td><td>is the parameter to be set; the enum MCFParam can be used, but 'par' is an int (every enum is an int) so that the method can be extended by derived classes for the setting of their parameters</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>is the value to assign to the parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>The base class implementation handles these parameters:</p>
<ul>
<li>kEpsFlw: sets the tolerance for controlling if the flow on an arc is zero to val. This also sets the tolerance for controlling if a node deficit is zero (see kEpsDfct) to val * &lt; max number of nodes &gt;; this value should be safe for graphs in which any node has less than &lt; max number of nodes &gt; adjacent nodes, i.e., for all graphs but for very dense ones with "parallel arcs"</li>
</ul>
<ul>
<li>kEpsDfct: sets the tolerance for controlling if a node deficit is zero to val, in case a better value than that autmatically set by kEpsFlw (see above) is available (e.g., val * k would be good if no node has more than k neighbours)</li>
</ul>
<ul>
<li>kEpsCst: sets the tolerance for controlling if the reduced cost of an arc is zero to val. A feasible solution satisfying eps-complementary slackness, i.e., such that <p class="formulaDsp">
<img class="formulaDsp" alt="\[ RC[ i , j ] < - eps \Rightarrow X[ i , j ] = U[ ij ] \]" src="form_13.png"/>
</p>
 and <p class="formulaDsp">
<img class="formulaDsp" alt="\[ RC[ i , j ] > eps \Rightarrow X[ i , j ] == 0 , \]" src="form_14.png"/>
</p>
 is known to be ( eps * n )-optimal.</li>
</ul>
<ul>
<li>kMaxTime: sets the max time (in seconds) in which the MCF Solver can find an optimal solution (default 0, which means no limit). </li>
</ul>

</div>
</div>
<a class="anchor" id="a3b0304010a92bd979f8681826f673c89"></a><!-- doxytag: member="MCFClass::SetPar" ref="a3b0304010a92bd979f8681826f673c89" args="(int par, int val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCFClass::SetPar </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set integer parameters of the algorithm.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>par</em>&nbsp;</td><td>is the parameter to be set; the enum MCFParam can be used, but 'par' is an int (every enum is an int) so that the method can be extended by derived classes for the setting of their parameters</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>is the value to assign to the parameter.</td></tr>
  </table>
  </dd>
</dl>
<p>The base class implementation handles these parameters:</p>
<ul>
<li>kMaxIter: the max number of iterations in which the MCF Solver can find an optimal solution (default 0, which means no limit)</li>
</ul>
<ul>
<li>kReopt: tells the solver if it has to reoptimize. The implementation in the base class sets a flag, the protected <code>bool</code> field <code>Senstv</code>; if true (default) this field instructs the MCF solver to to try to exploit the information about the latest optimal solution to speedup the optimization of the current problem, while if the field is false the MCF solver should restart the optimization "from scratch" discarding any previous information. Usually reoptimization speeds up the computation considerably, but this is not always true, especially if the data of the problem changes a lot. </li>
</ul>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#aa74a6bdb07ea07ae5a5729168a3c73b3">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a5e5f91a6212cf33b6a557a950ebea96f"></a><!-- doxytag: member="MCFClass::SolveMCF" ref="a5e5f91a6212cf33b6a557a950ebea96f" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void MCFClass::SolveMCF </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Solver of the Min Cost Flow Problem. Attempts to solve the MCF instance currently loaded in the object. </p>

<p>Implemented in <a class="el" href="classRelaxIV.html#a0dd84ccfd30d723d55b3ddcc039d6330">RelaxIV</a>.</p>

</div>
</div>
<a class="anchor" id="a8b35e744a87aa42f4a011c4bba8beb63"></a><!-- doxytag: member="MCFClass::TimeMCF" ref="a8b35e744a87aa42f4a011c4bba8beb63" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double MCFClass::TimeMCF </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Like TimeMCF(double,double) [see above], but returns the total time. </p>

</div>
</div>
<a class="anchor" id="a0da0f55010f95b1d9ffbee28375d03bb"></a><!-- doxytag: member="MCFClass::TimeMCF" ref="a0da0f55010f95b1d9ffbee28375d03bb" args="(double &amp;t_us, double &amp;t_ss)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCFClass::TimeMCF </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t_us</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>t_ss</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Time the code. If called within any of the methods of the class that are "actively timed" (this depends on the subclasses), this method returns the user and sistem time (in seconds) since the start of that method. If methods that are actively timed call other methods that are actively timed, <a class="el" href="classMCFClass.html#a8b35e744a87aa42f4a011c4bba8beb63">TimeMCF()</a> returns the (...) time since the beginning of the outer* actively timed method. If called outside of any actively timed method, this method returns the (...) time spent in all the previous executions of all the actively timed methods of the class.</p>
<p>Implementing the proper calls to MCFt-&gt;Start() and MCFt-&gt;Stop() is due to derived classes; these should at least be placed at the beginning and at the end, respectively, of <a class="el" href="classMCFClass.html#a5e5f91a6212cf33b6a557a950ebea96f">SolveMCF()</a> and presumably the Chg***() methods, that is, at least these methods should be "actively timed". </p>

</div>
</div>
<a class="anchor" id="a9694ac30a17e73567ff73f862bc49621"></a><!-- doxytag: member="MCFClass::WriteMCF" ref="a9694ac30a17e73567ff73f862bc49621" args="(ostream &amp;oStrm, int frmt=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCFClass::WriteMCF </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>oStrm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frmt</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the current MCF problem to an ostream. This may be useful e.g. for debugging purposes.</p>
<p>The base <a class="el" href="classMCFClass.html">MCFClass</a> class provides output in two different formats, depending on the value of the parameter frmt:</p>
<ul>
<li>kDimacs the problem is written in DIMACS standard format, read by most MCF codes available;</li>
</ul>
<ul>
<li>kMPS the problem is written in the "modern version" (tab-separated) of the MPS format, read by most LP/MIP solvers;</li>
</ul>
<ul>
<li>kFWMPS the problem is written in the "old version" (fixed width fields) of the MPS format; this is read by most LP/MIP solvers, but some codes still require the old format.</li>
</ul>
<p>The implementation of <a class="el" href="classMCFClass.html#a9694ac30a17e73567ff73f862bc49621">WriteMCF()</a> in the base class uses all the above methods for reading the data; as such it will work for any derived class that properly implements this part of the interface, but it may not be very efficient. Thus, the method is virtual to allow the derived classes to either re-implement <a class="el" href="classMCFClass.html#a9694ac30a17e73567ff73f862bc49621">WriteMCF()</a> for the above two formats in a more efficient way, and/or to extend it to support other solver-specific formats.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>None of the above two formats supports quadratic MCFs, so if nonzero quadratic coefficients are present, they are just ignored. </dd></dl>

<p>Reimplemented in <a class="el" href="classRelaxIV.html#a2992477971c60f53a63f726c2cfcb1da">RelaxIV</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="aca1100873955b9ba2f634c80e1551eef"></a><!-- doxytag: member="MCFClass::MaxIter" ref="aca1100873955b9ba2f634c80e1551eef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMCFClass.html#aca1100873955b9ba2f634c80e1551eef">MCFClass::MaxIter</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>max number of iterations in which MCF Solver can find an optimal solution (0 = no limits) </p>

</div>
</div>
<a class="anchor" id="ad9a37f6fc52cacde58c2ef399a6a3fe0"></a><!-- doxytag: member="MCFClass::MaxTime" ref="ad9a37f6fc52cacde58c2ef399a6a3fe0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classMCFClass.html#ad9a37f6fc52cacde58c2ef399a6a3fe0">MCFClass::MaxTime</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>max time (in seconds) in which MCF Solver can find an optimal solution (0 = no limits) </p>

</div>
</div>
<a class="anchor" id="a844dc956342baf3117fbe3087033085f"></a><!-- doxytag: member="MCFClass::status" ref="a844dc956342baf3117fbe3087033085f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classMCFClass.html#a844dc956342baf3117fbe3087033085f">MCFClass::status</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return status, see the comments to <a class="el" href="classMCFClass.html#a78b8a444e6030a7e508c17c82a54c4f2">MCFGetStatus()</a> above. Note that the variable is defined int to allow derived classes to return their own specialized status codes </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="MCFClass_8h_source.html">MCFClass.h</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Dec 6 18:53:17 2010 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
